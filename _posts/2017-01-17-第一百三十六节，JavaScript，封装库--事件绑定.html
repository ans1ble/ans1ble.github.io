第一百三十六节，JavaScript，封装库--事件绑定


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #0000ff"><strong>JavaScript，封装库--事件绑定</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>在函数库添加两个函数</strong></span></p>
<p><span style="color: #ff00ff"><strong><strong>添加事件绑定函数</strong></strong></span></p>
<p><span style="color: #ff00ff"><strong><strong>删除<strong><strong>事件绑定函数</strong></strong></strong></strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong><strong><strong><strong><strong><strong>添加事件绑定函数</strong></strong></strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">/*</span><span style="color: #008000">* addEvent()函数库函数，跨浏览器添加事件绑定,注意：传入事件名称时不要on
 * 接收3个参数
 * 参数1要绑定事件的元素对象，
 * 参数2事件名称，也就是什么事件，注意：传入事件名称时不要on
 * 参数3接收的事件执行函数
 * 注意：一个元素对象，执行了多个相同的事件函数时只执行一次，其他的会被忽略，注意是相同的事件函数
 * 说明：
 * 事件函数里的this，代表绑定事件元素对象本身
 * 事件函数里有一个可选参数e,e接收的元素event对象，传入addEvent()后跨浏览器获取到元素event对象，将元素event对象赋值给e
 * 所以事件函数里的e,代表元素event对象，前提是首先要在事件函数传参e后，再在事件函数里调用e,得到元素event对象
 * e.preventDefault()方法，在事件函数里写e.preventDefault()方法，兼容浏览器阻止事件元素对象默认行为，前提在事件函数要传参e
 * e.stopPropagation()方法，在事件函数里写e.stopPropagation()方法，阻止元素对象的父级元素事件冒泡行为，前提在事件函数要传参e
 *</span><span style="color: #008000">*/</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> addEvent(obj, type, fn) {
    </span><span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> obj.addEventListener != 'undefined'<span style="color: #000000">) {
        obj.addEventListener(type, fn, </span><span style="color: #0000ff">false</span><span style="color: #000000">);
    } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
        </span><span style="color: #008000">//</span><span style="color: #008000">创建一个存放事件的哈希表(散列表)</span>
        <span style="color: #0000ff">if</span> (!obj.events) obj.events =<span style="color: #000000"> {};
        </span><span style="color: #008000">//</span><span style="color: #008000">第一次执行时执行</span>
        <span style="color: #0000ff">if</span> (!<span style="color: #000000">obj.events[type]) {
            </span><span style="color: #008000">//</span><span style="color: #008000">创建一个存放事件处理函数的数组</span>
            obj.events[type] =<span style="color: #000000"> [];
            </span><span style="color: #008000">//</span><span style="color: #008000">把第一次的事件处理函数先储存到第一个位置上</span>
            <span style="color: #0000ff">if</span> (obj['on' + type]) obj.events[type][0] =<span style="color: #000000"> fn;
        } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
            </span><span style="color: #008000">//</span><span style="color: #008000">同一个注册函数进行屏蔽，不添加到计数器中</span>
            <span style="color: #0000ff">if</span> (addEvent.equal(obj.events[type], fn)) <span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
        }
        </span><span style="color: #008000">//</span><span style="color: #008000">从第二次开始我们用事件计数器来存储</span>
        obj.events[type][addEvent.ID++] =<span style="color: #000000"> fn;
        </span><span style="color: #008000">//</span><span style="color: #008000">执行事件处理函数</span>
        obj['on' + type] =<span style="color: #000000"> addEvent.exec;
    }
}
</span><span style="color: #008000">/*</span><span style="color: #008000">-------------------------------------------------------------------------------------</span><span style="color: #008000">*/</span>
<span style="color: #008000">//</span><span style="color: #008000">为每个事件分配一个计数器</span><span style="color: #008000">
//</span><span style="color: #008000">JS一切皆为对象，所以addEvent.ID语法正确，实际上是个全局变量</span>
addEvent.ID = 1<span style="color: #000000">;
</span><span style="color: #008000">//</span><span style="color: #008000">执行事件处理函数</span>
addEvent.exec = <span style="color: #0000ff">function</span><span style="color: #000000"> (event) {
    </span><span style="color: #0000ff">var</span> e = event ||<span style="color: #000000"> addEvent.fixEvent(window.event);
    </span><span style="color: #0000ff">var</span> es = <span style="color: #0000ff">this</span><span style="color: #000000">.events[e.type];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> es) {
        es[i].call(</span><span style="color: #0000ff">this</span><span style="color: #000000">, e);
    }
};
</span><span style="color: #008000">//</span><span style="color: #008000">同一个注册函数进行屏蔽</span>
addEvent.equal = <span style="color: #0000ff">function</span><span style="color: #000000"> (es, fn) {
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> es) {
        </span><span style="color: #0000ff">if</span> (es[i] == fn) <span style="color: #0000ff">return</span> <span style="color: #0000ff">true</span><span style="color: #000000">;
    }
    </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
};
</span><span style="color: #008000">//</span><span style="color: #008000">把IE常用的Event对象配对到W3C中去</span>
addEvent.fixEvent = <span style="color: #0000ff">function</span><span style="color: #000000"> (event) {
    event.preventDefault </span>=<span style="color: #000000"> addEvent.fixEvent.preventDefault;
    event.stopPropagation </span>=<span style="color: #000000"> addEvent.fixEvent.stopPropagation;
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> event;
};
</span><span style="color: #008000">//</span><span style="color: #008000">IE阻止默认行为</span>
addEvent.fixEvent.preventDefault = <span style="color: #0000ff">function</span><span style="color: #000000"> () {
    </span><span style="color: #0000ff">this</span>.returnValue = <span style="color: #0000ff">false</span><span style="color: #000000">;
};
</span><span style="color: #008000">//</span><span style="color: #008000">IE取消冒泡</span>
addEvent.fixEvent.stopPropagation = <span style="color: #0000ff">function</span><span style="color: #000000"> () {
    </span><span style="color: #0000ff">this</span>.cancelBubble = <span style="color: #0000ff">true</span><span style="color: #000000">;
};
</span><span style="color: #008000">/*</span><span style="color: #008000">---------------------------------------------------------------------------------------</span><span style="color: #008000">*/</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong><strong>删除<strong><strong>事件绑定函数</strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">/*</span><span style="color: #008000">* removeEvent()函数库函数，跨浏览器删除事件绑定,注意：传入事件名称时不要on
 * 接收3个参数
 * 参数1接收事件绑定时的元素对象
 * 参数2接收事件绑定时的事件名称，也就是什么事件，注意：传入事件名称时不要on
 * 参数3接收事件绑定时的执行函数
 *</span><span style="color: #008000">*/</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> removeEvent(obj, type, fn) {
    </span><span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> obj.removeEventListener != 'undefined'<span style="color: #000000">) {
        obj.removeEventListener(type, fn, </span><span style="color: #0000ff">false</span><span style="color: #000000">);
    } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
        </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> obj.events[type]) {
            </span><span style="color: #0000ff">if</span> (obj.events[type][i] ==<span style="color: #000000"> fn) {
                </span><span style="color: #0000ff">delete</span><span style="color: #000000"> obj.events[type][i];
            }
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p></div>