第五十五节，IO多路复用select模块加socket模块，伪多线并发


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #ff0000; font-size: 18pt;"><strong class="fl">IO多路复用select模块加socket模块，伪多线并发，并不是真正的多线程并发，实际通过循环等待还是一个一个处理的</strong></span></p>
<p><strong class="fl">IO多路复用，lo就是文件或数据的输入输出，<strong class="fl">IO多路复用就是可以多用户操作</strong></strong></p>
<p><strong class="fl"><strong class="fl"><strong class="fl">IO多路复用，</strong>可以监听多个文件描述符（socke对象）（文件句柄），一旦文件句柄出现变化，即可感知到，感知到后作出相应操作</strong></strong></p>
<p>&nbsp;</p>
<p><strong class="fl"><strong class="fl">比如原生<strong class="fl"><strong class="fl">socke模块只能监听一个端口和只能一个用户连接，要想实现监听多个端口和支持多用户，就会使用<strong class="fl">IO多路复用</strong></strong></strong></strong></strong></p>
<p>&nbsp;</p>
<p><span style="color: #0000ff;"><strong>IO多路复用select模块</strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">select()自动监听socket对象的客户端，连接地址和、客户端通讯地址，四个参数</strong></strong></strong></strong></strong></span></p>
<p><span style="color: #000000;">select()自动监听列表里的socket对象（文件描述符），一旦监听的对象，谁发生了变化（有用户请求），<br />就将发生变化对象的客户端连接地址赋值给第一个变量a，第一个变量接收的列表，列表里的每一个元素，就是一个端口的用户连接地址<br />如果是多个端口在同时连接客户端，那么列表元素就是多个元素</span></p>
<p><span style="color: #000000;">最多监听端口1024个</span></p>
<p><span style="color: #000000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">使用方法：a, b, c = select.select(列表类型的<strong class="fl"><strong class="fl">socke对象变化</strong></strong>, [可选：传参直接赋值给第二个变量], [可选：<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">列表类型的<strong class="fl"><strong class="fl">socke对象监听错误</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>], 多少秒检测一次)</strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　<span style="color: #0000ff;">　需要四个参数　</span></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　参数一：<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">列表类型的<strong class="fl"><strong class="fl">socke对象，监听变化</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　参数二：<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">传参直接赋值给第二个变量</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　参数三：<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">列表类型的<strong class="fl"><strong class="fl">socke对象，监听错误</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　参数四：<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">多少秒检测一次</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　<span style="color: #0000ff;">需要三个变量来接收返回值</span></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><span style="color: #0000ff;">　　<span style="color: #ff0000;">第一个变量接收的：列表类型客户端连接地址，如果无客户端连接则为空列表</span></span></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><span style="color: #0000ff;"><span style="color: #ff0000;">　　<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">第二个变量接收的：第二个参数的值</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></span></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><span style="color: #0000ff;"><span style="color: #ff0000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">　　第三个变量接收的：第三个参数监听<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">socke对象的错误信息,返回列表，无错误则为空列表</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br /></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></span></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">格式：a, b, c = select.select(lib, [], [], 1)</strong></strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">格式2：a, b, c = select.select(lib, k1, <strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">lib</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>, 1)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #0000ff;"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong>IO多路复用</strong>多端口监听客户端连接地址、服务端代码</strong></strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">服务端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">设置多个对象，绑定不同端口</span><span style="color: #800000;">"""</span><span style="color: #000000;">
k1 </span>= socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建对象</span>
k1.bind((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991)) <span style="color: #008000;">#</span><span style="color: #008000;">绑定服务端IP和端口</span>
k1.listen() <span style="color: #008000;">#</span><span style="color: #008000;">监听IP和端口</span>
<span style="color: #000000;">
k2 </span>= socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建对象</span>
k2.bind((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9992)) <span style="color: #008000;">#</span><span style="color: #008000;">绑定服务端IP和端口</span>
k2.listen() <span style="color: #008000;">#</span><span style="color: #008000;">监听IP和端口</span>
<span style="color: #000000;">
k3 </span>= socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建对象</span>
k3.bind((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9993)) <span style="color: #008000;">#</span><span style="color: #008000;">绑定服务端IP和端口</span>
k3.listen() <span style="color: #008000;">#</span><span style="color: #008000;">监听IP和端口</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">将多个对象组合成列表</span><span style="color: #800000;">"""</span><span style="color: #000000;">
lib </span>=<span style="color: #000000;"> [k1, k2, k3]

</span><span style="color: #800000;">"""</span><span style="color: #800000;">使用自动监听模块</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> select <span style="color: #008000;">#</span><span style="color: #008000;">导入自动监听多个端口模块</span>
<span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">select()自动监听列表里的socket对象（文件描述符），一旦监听的对象，谁发生了变化（有用户请求），</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 就将发生变化对象的客户端连接地址赋值给第一个变量a，第一个变量接收的列表，列表里的每一个元素，就是一个端口的用户连接地址</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">如果是多个端口在同时连接客户端，那么列表元素就是多个元素</span>
    a, b, c = select.select(lib, [], [], 1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span> k <span style="color: #0000ff;">in</span> a: <span style="color: #008000;">#</span><span style="color: #008000;">循环出select()获取到的列表类型客户端连接地址</span>
        d, e = k.accept() <span style="color: #008000;">#</span><span style="color: #008000;">将循环到的每一个客户端连接地址等待通讯，阻塞</span>
        d.sendall(bytes(<span style="color: #800000;">"</span><span style="color: #800000;">欢迎访问</span><span style="color: #800000;">"</span>, encoding=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span>)) <span style="color: #008000;">#</span><span style="color: #008000;">向连接的客户端发送一条消息</span></pre>
</div>
<p><span style="color: #0000ff;"><strong>客户端代码1</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">创建客户端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
z = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建socket对象</span>
b = z.connect((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991,))<span style="color: #008000;">#</span><span style="color: #008000;">连接服务端，在客户端绑定服务端IP和端口</span>
<span style="color: #000000;">
f </span>= z.recv(1024) <span style="color: #008000;">#</span><span style="color: #008000;">客户端接收服务端sendall()发来的信息，1024表示最大接收1024字节</span>
f2 = str(f, encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到的服务端字节信息转换成字符串</span>
<span style="color: #0000ff;">print</span>(f2) <span style="color: #008000;">#</span><span style="color: #008000;">打印出服务端发来的信息</span></pre>
</div>
<p><span style="color: #0000ff;"><strong>客户端代码2</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">创建客户端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
z = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建socket对象</span>
b = z.connect((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9992,))<span style="color: #008000;">#</span><span style="color: #008000;">连接服务端，在客户端绑定服务端IP和端口</span>
<span style="color: #000000;">
f </span>= z.recv(1024) <span style="color: #008000;">#</span><span style="color: #008000;">客户端接收服务端sendall()发来的信息，1024表示最大接收1024字节</span>
f2 = str(f, encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到的服务端字节信息转换成字符串</span>
<span style="color: #0000ff;">print</span>(f2) <span style="color: #008000;">#</span><span style="color: #008000;">打印出服务端发来的信息</span></pre>
</div>
<p><span style="color: #0000ff;"><strong>IO多路复用<strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl">多端口监听、客户端连接地址原理图</strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #0000ff;"><strong><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><strong class="fl"><img src="https://images2015.cnblogs.com/blog/955761/201609/955761-20160928190658813-1825178017.png" alt="" /></strong></strong></strong></strong></strong></strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #0000ff;"><strong>IO多路复用监听客户端多通讯地址</strong></span></p>
<p><span style="color: #ff0000;"><strong>通过select()监听到客户端变化信息对象，拿到变化信息对象，判断是连接信息对象，还是通讯信息对象？如果是连接信息对象，通过变化信息对象获取到此连接的通讯对象，将通讯对象添加到<strong>select()里监听，如果是通讯对象，通过通讯对象进行信息交互</strong></strong></span></p>
<p><span style="color: #0000ff;"><strong><strong><strong>IO多路复用监听客户端多通讯地址服务端代码</strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">服务端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
k1 = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建对象</span>
k1.bind((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991)) <span style="color: #008000;">#</span><span style="color: #008000;">绑定服务端IP和端口</span>
k1.listen() <span style="color: #008000;">#</span><span style="color: #008000;">监听IP和端口</span>
lib =<span style="color: #000000;"> [k1]

</span><span style="color: #800000;">"""</span><span style="color: #800000;">使用自动监听模块</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> select <span style="color: #008000;">#</span><span style="color: #008000;">导入自动监听多个端口模块</span>
<span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">select()自动监听列表里的socket对象（文件描述符），一旦监听的对象，谁发生了变化（有用户请求），</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 就将发生变化对象的客户端连接地址赋值给第一个变量a，第一个变量接收的列表，列表里的每一个元素，就是一个端口的用户连接地址</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">如果是多个端口在同时连接客户端，那么列表元素就是多个元素</span>
    a, b, c = select.select(lib, [], [], 1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">正在监听的socket对象 %d</span><span style="color: #800000;">"</span> % len(lib)) <span style="color: #008000;">#</span><span style="color: #008000;">监听的对象有多少个</span>
    <span style="color: #0000ff;">print</span>(a) <span style="color: #008000;">#</span><span style="color: #008000;">监听发生变化的有哪些</span>
    <span style="color: #0000ff;">for</span> k <span style="color: #0000ff;">in</span> a: <span style="color: #008000;">#</span><span style="color: #008000;">循环出select()获取到的列表类型客户端连接地址</span>
        <span style="color: #0000ff;">if</span> k == k1: <span style="color: #008000;">#</span><span style="color: #008000;">判断循环到的连接地址等于socket对象，说明有新用户连接</span>
            d, e = k.accept() <span style="color: #008000;">#</span><span style="color: #008000;">等待请求，获取客户端通讯地址</span>
            lib.append(d) <span style="color: #008000;">#</span><span style="color: #008000;">将客户端通讯地址追加到列表，传入select()监听通讯变化</span>
            d.sendall(bytes(<span style="color: #800000;">"</span><span style="color: #800000;">你好</span><span style="color: #800000;">"</span>, encoding=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">))
        </span><span style="color: #0000ff;">else</span>: <span style="color: #008000;">#</span><span style="color: #008000;">如果不是连接信息，说明是通讯信息</span>
            <span style="color: #0000ff;">try</span>: <span style="color: #008000;">#</span><span style="color: #008000;">监控代码是否出现异常，如果客户端关闭了就会出现异常，没出现异常执行里面的代码</span>
                fd = k.recv(1024<span style="color: #000000;">)
                f </span>= str(fd, encoding=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">)
                g </span>= f + <span style="color: #800000;">"</span><span style="color: #800000;">好</span><span style="color: #800000;">"</span><span style="color: #000000;">
                k.sendall(bytes(g, encoding</span>=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">))
            </span><span style="color: #0000ff;">except</span> Exception as ex: <span style="color: #008000;">#</span><span style="color: #008000;">出现异常将当前通讯对象移除列表，select不在监听</span>
                lib.remove(k)</pre>
</div>
<p><span style="color: #0000ff;"><strong>客户端代码</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">创建客户端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
z = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建socket对象</span>
b = z.connect((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991,))<span style="color: #008000;">#</span><span style="color: #008000;">连接服务端，在客户端绑定服务端IP和端口</span>
<span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    f </span>= z.recv(1024) <span style="color: #008000;">#</span><span style="color: #008000;">客户端接收服务端sendall()发来的信息，1024表示最大接收1024字节</span>
    f2 = str(f, encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到的服务端字节信息转换成字符串</span>
    <span style="color: #0000ff;">print</span>(f2) <span style="color: #008000;">#</span><span style="color: #008000;">打印出服务端发来的信息</span>
    a = input(<span style="color: #800000;">"</span><span style="color: #800000;">输入要发送的信息</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    z.sendall(bytes(a, encoding</span>=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span>))</pre>
</div>
<p><span style="color: #0000ff;">&nbsp;<strong>IO多路复用监听客户端多通讯原理图</strong></span></p>
<p><span style="color: #0000ff;"><strong><img src="https://images2015.cnblogs.com/blog/955761/201609/955761-20160929110227610-1523795347.png" alt="" /></strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>IO多路复用,有三种方式(select)、(poll)、(epoll) select和poll其实都是调用计算机底层来实现的监听处理，<strong>epoll</strong>是异步处理的是文件描述符发生变化后主动告诉<strong>epoll</strong>的，这里我们需要知道一下</strong></span></p>
<p><span style="color: #ff0000;"><strong>注意：wds系统只支持<strong>select模块，</strong></strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #0000ff;"><strong>利用select()的第二个参数，实现IO多路复用，服务端读写分离</strong></span><br /><span style="color: #000000;"><strong>也就是读和写分开，在不同的代码块</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #0000ff;"><strong>服务端读写分离代码</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">服务端实现读写分离</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
k1 = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建对象</span>
k1.bind((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991)) <span style="color: #008000;">#</span><span style="color: #008000;">绑定服务端IP和端口</span>
k1.listen() <span style="color: #008000;">#</span><span style="color: #008000;">监听IP和端口</span>
<span style="color: #000000;">
lib </span>= [k1] <span style="color: #008000;">#</span><span style="color: #008000;">监听的客户连接地址或，客户通讯地址,传给select第一个参数</span>
lib2 = [] <span style="color: #008000;">#</span><span style="color: #008000;">接收客户端通讯地址，传给select第二个参数</span>
jilu = {} <span style="color: #008000;">#</span><span style="color: #008000;">接收字典，里面是客户端发通讯内容的用户通讯地址(键)和通讯内容(值)</span>

<span style="color: #800000;">"""</span><span style="color: #800000;">使用自动监听模块</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> select <span style="color: #008000;">#</span><span style="color: #008000;">导入自动监听多个端口模块</span>
<span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">select()自动监听列表里的socket对象（文件描述符），一旦监听的对象，谁发生了变化（有用户请求），</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 就将发生变化对象的客户端连接地址赋值给第一个变量a，第一个变量接收的列表，列表里的每一个元素，就是一个端口的用户连接地址</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">如果是多个端口在同时连接客户端，那么列表元素就是多个元素</span>
    a, b, c = select.select(lib, lib2, lib, 1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">正在监听的socket对象 %d</span><span style="color: #800000;">"</span> % len(lib)) <span style="color: #008000;">#</span><span style="color: #008000;">监听的对象有多少个</span>
    <span style="color: #0000ff;">print</span>(a) <span style="color: #008000;">#</span><span style="color: #008000;">监听发生变化的有哪些</span>
    <span style="color: #800000;">"""</span><span style="color: #800000;">循环判断链接地址或通讯地址，获取客户端通讯信息以及内容</span><span style="color: #800000;">"""</span>
    <span style="color: #0000ff;">for</span> k <span style="color: #0000ff;">in</span> a: <span style="color: #008000;">#</span><span style="color: #008000;">循环出select()获取到的列表类型客户端连接地址</span>
        <span style="color: #0000ff;">if</span> k == k1: <span style="color: #008000;">#</span><span style="color: #008000;">判断循环到的连接地址等于socket对象，说明有新用户连接</span>
            d, e = k.accept() <span style="color: #008000;">#</span><span style="color: #008000;">等待请求，获取客户端通讯地址</span>
            lib.append(d) <span style="color: #008000;">#</span><span style="color: #008000;">将客户端通讯地址追加到列表，传入select()监听通讯变化</span>
            jilu[d] = [] <span style="color: #008000;">#</span><span style="color: #008000;">将连接用户通讯地址添加到字典为键，值为空列表</span>
        <span style="color: #0000ff;">else</span>: <span style="color: #008000;">#</span><span style="color: #008000;">如果不是连接信息，说明是通讯信息</span>
            <span style="color: #0000ff;">try</span>: <span style="color: #008000;">#</span><span style="color: #008000;">监控代码是否异常</span>
                fd = k.recv(1024) <span style="color: #008000;">#</span><span style="color: #008000;">获取客户端发的信息</span>
            <span style="color: #0000ff;">except</span> Exception as e: <span style="color: #008000;">#</span><span style="color: #008000;">如果异常将此通讯地址移除列表，停止监听</span>
                lib.remove(k) <span style="color: #008000;">#</span><span style="color: #008000;">通讯地址移除列表</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;">:
                fd2 </span>= str(fd, encoding=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span>) <span style="color: #008000;">#</span><span style="color: #008000;">接收客户端发的信息转换成字符串</span>
                jilu[k].append(fd2) <span style="color: #008000;">#</span><span style="color: #008000;"> 将客户端转换的字符串追加到，字典里当前客户键的，列表里为值</span>
                lib2.append(k) <span style="color: #008000;">#</span><span style="color: #008000;">将当前客户通讯地址，添加到select第二个参数列表里</span>
    <span style="color: #800000;">"""</span><span style="color: #800000;">向客户端发信息</span><span style="color: #800000;">"""</span>
    <span style="color: #0000ff;">for</span> km <span style="color: #0000ff;">in</span> b: <span style="color: #008000;">#</span><span style="color: #008000;">循环select第二个参数列表里的通讯用户</span>
        jkd = jilu[km][0] <span style="color: #008000;">#</span><span style="color: #008000;">通过通讯用户拿到字典里对应的通讯内容</span>
        <span style="color: #0000ff;">del</span> jilu[km][0] <span style="color: #008000;">#</span><span style="color: #008000;">拿到通讯内容后删除通讯内容</span>
        km.sendall(bytes(jkd+<span style="color: #800000;">"</span><span style="color: #800000;">好</span><span style="color: #800000;">"</span>, encoding=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span>)) <span style="color: #008000;">#</span><span style="color: #008000;">将通讯内容加个好字，在发给客户端</span>
        lib2.remove(km ) <span style="color: #008000;">#</span><span style="color: #008000;">在通讯列表移除当前通讯地址</span>

    <span style="color: #0000ff;">for</span> fh <span style="color: #0000ff;">in</span> c: <span style="color: #008000;">#</span><span style="color: #008000;">如果监听连接出现异常</span>
        lib.remove(fh) <span style="color: #008000;">#</span><span style="color: #008000;">移除当前连接</span></pre>
</div>
<p><strong><span style="color: #0000ff;">客户端代码</span></strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">创建客户端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socket <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>
z = socket.socket() <span style="color: #008000;">#</span><span style="color: #008000;">创建socket对象</span>
b = z.connect((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9991,))<span style="color: #008000;">#</span><span style="color: #008000;">连接服务端，在客户端绑定服务端IP和端口</span>
<span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    a </span>= input(<span style="color: #800000;">"</span><span style="color: #800000;">输入要发送的信息</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    z.sendall(bytes(a, encoding</span>=<span style="color: #800000;">"</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">))
    f </span>= z.recv(1024) <span style="color: #008000;">#</span><span style="color: #008000;">客户端接收服务端sendall()发来的信息，1024表示最大接收1024字节</span>
    f2 = str(f, encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到的服务端字节信息转换成字符串</span>
    <span style="color: #0000ff;">print</span>(f2) <span style="color: #008000;">#</span><span style="color: #008000;">打印出服务端发来的信息</span></pre>
</div>
<p><span style="color: #0000ff;">&nbsp;<strong>IO多路复用，服务端读写分离原理图</strong></span></p>
<p><span style="color: #0000ff;"><strong><img src="https://images2015.cnblogs.com/blog/955761/201609/955761-20160930164848625-2047340885.png" alt="" /></strong></span></p></div>