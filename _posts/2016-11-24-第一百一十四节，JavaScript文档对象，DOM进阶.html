第一百一十四节，JavaScript文档对象，DOM进阶


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #0000ff"><strong><span style="font-size: 18pt">JavaScript文档对象，DOM进阶</span></strong></span></p>
<p>&nbsp;</p>
<p align="left"><strong>学习要点：</strong></p>
<p align="left"><strong>1.DOM类型</strong></p>
<p align="left"><strong>2.DOM扩展</strong></p>
<p align="left"><strong>3.DOM操作内容</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><strong>DOM自身存在很多类型，在DOM基础课程中大部分都有所接触，比如Element类型：表示的是元素节点，再比如Text类型：表示的是文本节点。DOM也提供了一些扩展功能。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong>一．</strong><strong>DOM</strong><strong>类型</strong></span></p>
<p align="left"><strong>DOM基础课程中，我们了解了DOM的节点并且了解怎样查询和操作节点，而本身这些不同的节点，又有着不同的类型。</strong></p>
<p>&nbsp;</p>
<p align="center"><span style="color: #ff0000"><strong>DOM类型</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="192">
<p align="center"><strong>类型名</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>说明</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Node</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示所有类型值的统一接口，IE不支持</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Document</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示文档类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Element</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示元素节点类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Text</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示文本节点类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Comment</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示文档中的注释类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>CDATASection</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示CDATA区域类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>DocumentType</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示文档声明类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>DocumentFragment</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示文档片段类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>Attr</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>表示属性节点类型</strong></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="center"><strong>&nbsp;</strong></p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>1.Node类型，返回值表示<strong>Node类型的数值</strong></strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>Node接口是DOM1级就定义了，Node接口定义了12个数值常量以表示每个节点的类型值。<span style="color: #0000ff">除了IE之外</span>，所有浏览器都可以访问这个类型。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="center"><span style="color: #ff0000"><strong>Node的常量</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="258">
<p align="center"><strong>常量名</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>说明</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>nodeType值</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>ELEMENT_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>元素</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>1</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>ATTRIBUTE_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>属性</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>2</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>TEXT_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>文本</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>3</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>CDATA_SECTION_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>CDATA</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>4</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>ENTITY_REFERENCE_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>实体参考</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>5</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>ENTITY_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>实体</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>6</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>PROCESSING_INSTRUCETION_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>处理指令</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>7</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>COMMENT_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>注释</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>8</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>DOCUMENT_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>文档根</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>9</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>DOCUMENT_TYPE_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>doctype,html文档声明类型</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>10</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>DOCUMENT_FRAGMENT_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>文档片段</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>11</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="258">
<p align="center"><strong>NOTATION_NODE</strong></p>
</td>
<td valign="top" width="141">
<p align="center"><strong>符号</strong></p>
</td>
<td valign="top" width="95">
<p align="center"><strong>12</strong></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="center">&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>&nbsp;</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>虽然这里介绍了12种节点对象的属性，用的多的其实也就几个而已。</strong></span></p>
<div class="cnblogs_code">
<pre>alert(Node.ELEMENT_NODE);                <span style="color: #008000">//</span><span style="color: #008000">1，元素节点类型值</span>
alert(Node.TEXT_NODE);                    <span style="color: #008000">//</span><span style="color: #008000">2，文本节点类型值<br><br>注意：低版本ie不支持，下面会有解决方案</span></pre>
</div>
<p><span style="color: #ff0000"><strong>ELEMENT_NODE，表示<strong>元素节点返回值是1 ，</strong>实际使用方式如下</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box'); <span style="color: #008000">//</span><span style="color: #008000">通过ID获取到目标节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">判断元素节点的类型，如果等于文本类型</span>
    <span style="color: #0000ff">if</span>(asf.nodeType === Node.ELEMENT_NODE){  <span style="color: #008000">//</span><span style="color: #008000">ELEMENT_NODE，表示元素节点返回值是1</span>
        alert("元素类型节点"<span style="color: #000000">);
    }</span><span style="color: #0000ff">else</span><span style="color: #000000"> {
        alert(</span>"不是元素类型节点"<span style="color: #000000">)
    }
};

</span><span style="color: #008000">//</span><span style="color: #008000">元素类型节点</span></pre>
</div>
<p><span style="color: #0000ff"><strong>ps:其他属性使用方式相同</strong></span></p>
<p align="left"><strong>我们建议使用Node类型的属性来代替1,2这些阿拉伯数字，有可能大家会觉得这样岂不是很繁琐吗？并且还有一个问题就是IE不支持Node类型。</strong><br><strong>如果只有两个属性的话，用1，2来代替会特别方便，但如果属性特别多的情况下，1、2、3、4、5、6、7、8、9、10、11、12，你根本就分不清哪个数字代表的是哪个节点。当然，如果你只用1，2两个节点，那就另当别论了。</strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong>Node类型</strong>IE低版本不支持，我们可以模拟一个类，让IE也支持</strong></span></p>
<div class="cnblogs_code">
<pre>alert(Node.ELEMENT_NODE);                <span style="color: #008000">//</span><span style="color: #008000">1，元素节点类型值</span>
alert(Node.TEXT_NODE);                    <span style="color: #008000">//</span><span style="color: #008000">2，文本节点类型值</span>

<span style="color: #008000">//</span><span style="color: #008000">Node类型IE低版本不支持，我们可以模拟一个类，让IE也支持</span><span style="color: #008000">
//</span><span style="color: #008000">判断Node的类型如果等于undefined，就说明此浏览器不支持Node类型</span>
<span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> Node === 'undefined'<span style="color: #000000">){
    </span><span style="color: #008000">//</span><span style="color: #008000">通过window创建一个对象全局变量</span>
    window.Node =<span style="color: #000000">{
        ELEMENT_NODE:</span>1<span style="color: #000000">,
        ATTRIBUTE_NODE:</span>2<span style="color: #000000">,
        TEXT_NODE:</span>3<span style="color: #000000">,
        CDATA_SECTION_NODE:</span>4<span style="color: #000000">,
        ENTITY_REFERENCE_NODE:</span>5<span style="color: #000000">,
        ENTITY_NODE:</span>6<span style="color: #000000">,
        PROCESSING_INSTRUCETION_NODE:</span>7<span style="color: #000000">,
        COMMENT_NODE:</span>8<span style="color: #000000">,
        DOCUMENT_NODE:</span>9<span style="color: #000000">,
        DOCUMENT_TYPE_NODE:</span>10<span style="color: #000000">,
        DOCUMENT_FRAGMENT_NODE:</span>11<span style="color: #000000">,
        NOTATION_NODE:</span>12<span style="color: #000000">
    };
}</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>2.Document类型，返回根节点对象</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>document类型表示文档，或文档的根节点，而这个节点是隐藏的，没有具体的元素标签。也就是所有的html都是在这个节点下的，这个是根</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document);   <span style="color: #008000">//</span><span style="color: #008000">document类型表示文档，或文档的根节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回[object HTMLDocument],返回根节点对象</span>
<span style="color: #000000">
    alert(document.nodeType);  </span><span style="color: #008000">//</span><span style="color: #008000">查看文档类型值</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回9，表示文档根</span>
<span style="color: #000000">
    alert(document.childNodes[</span>0]); <span style="color: #008000">//</span><span style="color: #008000">获取根元素节点里的第一个子节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回[object DocumentType]，第一个子节点对象</span>
<span style="color: #000000">
    alert(document.childNodes[</span>0].nodeType); <span style="color: #008000">//</span><span style="color: #008000">查看第一个子节点的类型</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回10，表示html文档声明类型</span>
<span style="color: #000000">
    alert(document.childNodes[</span>1]); <span style="color: #008000">//</span><span style="color: #008000">获取根元素节点里的第二个子节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回[object HTMLHtmlElement]，第二个子节点对象</span>
<span style="color: #000000">
    alert(document.childNodes[</span>1].nodeType); <span style="color: #008000">//</span><span style="color: #008000">查看第二个子节点的类型</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回1，表示是元素类型也就是标签</span>
<span style="color: #000000">
    alert(document.childNodes[</span>1].nodeName);  <span style="color: #008000">//</span><span style="color: #008000">获取第二个子节点的标签名称</span>
    <span style="color: #008000">//</span><span style="color: #008000">HTML，表示是html标签</span>
};</pre>
</div>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>如果想直接得到&lt;html&gt;标签的元素节点对象HTMLHtmlElement，不必使用childNodes属性这么麻烦，可以使用documentElement即可。</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>documentElement属性，直接获取根节点下的html节点，返回html节点对象</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.documentElement);  <span style="color: #008000">//</span><span style="color: #008000">documentElement属性，直接获取根节点下的html节点，返回html节点对象</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回，[object HTMLHtmlElement] html节点对象</span>
<span style="color: #000000">
    alert(document.documentElement.nodeName); </span><span style="color: #008000">//</span><span style="color: #008000">获取html节点的标签名称</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回，HTML 标签名称</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>在很多情况下，我们并不需要得到&lt;html&gt;标签的元素节点，而需要得到更常用的&lt;body&gt;标签，之前我们采用的是：document.getElementsByTagName('body')[0]，那么这里提供一个更加简便的方法：document.body。</strong></span></p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong>body属性，直接获取body标签节点</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.body);  <span style="color: #008000">//</span><span style="color: #008000">body属性，直接获取body标签节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：[object HTMLBodyElement] body标签节点对象</span>
<span style="color: #000000">
    alert(document.body.nodeName); </span><span style="color: #008000">//</span><span style="color: #008000">获取body标签名称</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：BODY  标签名称</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>在&lt;html&gt;之前还有一个文档声明：&lt;!DOCTYPE&gt;会作为某些浏览器的第一个节点来处理，这里提供了一个简便方法来处理：document.doctype。</strong></span></p>
<p><span style="color: #ff0000"><strong>doctype属性，直接获取html文档声明标签节点</strong></span><br><span style="color: #0000ff"><strong>注意：ie7以下不支持，ie7以下只能通过父节点获取子节点得到，并且得到的是文档注释类型，不是元素类型</strong></span></p>
<p align="left">PS：IE8中，如果使用子节点访问，IE8之前会解释为注释类型Comment节点，而document.doctype则会返回null。</p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.doctype);  <span style="color: #008000">//</span><span style="color: #008000">doctype属性，直接获取html文档声明标签节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：[object DocumentType] 文档声明标签节点对象</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><span style="background-color: #ffffff"><strong>Document中有一些遗留的属性和对象合集，可以快速的帮助我们精确的处理一些任务</strong></span><span style="background-color: #ffffff"><strong>。</strong></span></span></p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong>title属性，获取和设置&lt;title&gt;标签的值</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.title);  <span style="color: #008000">//</span><span style="color: #008000">title属性，获取和设置&lt;title&gt;标签的值</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：JavaScript讲解</span>
<span style="color: #000000">
    alert(document.title </span>= '修改标题');  <span style="color: #008000">//</span><span style="color: #008000">设置&lt;title&gt;标签的值</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：修改标题</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>URL属性，获取URL路径</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.URL);  <span style="color: #008000">//</span><span style="color: #008000">URL属性，获取URL路径</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：http://localhost:63342/js/1.html?_ijt=d9jd9jpm38tl3bb99qlpgr4rbo </span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>domain属性，获取域名，要在服务器端</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.domain);  <span style="color: #008000">//</span><span style="color: #008000">domain属性，获取域名，要在服务器端</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：localhost </span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>referrer属性，获取上一个URL，要在服务器端</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.referrer);  <span style="color: #008000">//</span><span style="color: #008000">referrer属性，获取上一个URL，要在服务器端,如果上一页没有返回空</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>anchors属性，获取文档中带name属性的&lt;a&gt;元素集合</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.anchors);  <span style="color: #008000">//</span><span style="color: #008000">anchors属性，获取文档中带name属性的&lt;a&gt;元素集合</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>links属性，获取文档中带href属性的&lt;a&gt;元素集合</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.links);  <span style="color: #008000">//</span><span style="color: #008000">links属性，获取文档中带href属性的&lt;a&gt;元素集合</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>forms属性，获取文档中&lt;form&gt;元素集合</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.forms);  <span style="color: #008000">//</span><span style="color: #008000">forms属性，获取文档中&lt;form&gt;元素集合</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>images属性，获取文档中&lt;img&gt;元素集合</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    alert(document.images);  <span style="color: #008000">//</span><span style="color: #008000">images属性，获取文档中&lt;img&gt;元素集合</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>3.Element元素类型</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>Element类型用于表现HTML中的元素节点。在DOM基础那章，我们已经可以对元素节点进行查找、创建等操作，元素节点的nodeType为1，nodeName为元素的标签名。</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>元素节点对象在非IE浏览器可以返回它具体元素节点的对象类型。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="center"><span style="color: #ff0000"><strong>元素对应类型表</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="192">
<p align="center"><strong>元素名</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>类型</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>HTML</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>HTMLHtmlElement</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>DIV</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>HTMLDivElement</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>BODY</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>HTMLBodyElement</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>P</strong></p>
</td>
<td valign="top" width="306">
<p align="center"><strong>HTMLParamElement</strong></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="left"><span style="color: #0000ff; background-color: #ffffff"><strong>PS：以上给出了部分对应，更多的元素对应类型，直接访问调用即可</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>4.Text类型</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>Text类型用于表现文本节点类型，文本不包含HTML，或包含转义后的HTML。文本节点的nodeType为3。</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>在同时创建两个同一级别的文本节点的时候，会产生分离的两个节点。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>在同时创建两个同一级别的文本节点的时候，会产生分离的两个节点。</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    <span style="color: #0000ff">var</span> text1 = document.createTextNode('文本1'); <span style="color: #008000">//</span><span style="color: #008000">创建一个文本节点</span>
    <span style="color: #0000ff">var</span> text2 = document.createTextNode('文本2'); <span style="color: #008000">//</span><span style="color: #008000">创建一个文本节点</span>
    sdf.appendChild(text1); <span style="color: #008000">//</span><span style="color: #008000">将新节点添加到sdf节点里子节点末尾</span>
    sdf.appendChild(text2); <span style="color: #008000">//</span><span style="color: #008000">将新节点添加到sdf节点里子节点末尾</span>
    alert(sdf.childNodes.length);  <span style="color: #008000">//</span><span style="color: #008000">查看元素节点里的子节点集合长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回2，说明是两个文本节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;文本1文本2&lt;/div&gt;</span>
    <span style="color: #008000">//</span><span style="color: #008000">注意：此时添加了两个文本节点，但是用眼睛看就像是一个文本节点，这里一点要注意</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>normalize()合并同级的文本节点</strong></span></p>
<p><span style="color: #000000"><strong>使用方式：</strong></span></p>
<p><span style="color: #000000"><strong>目标节点的父节点.<strong>normalize()</strong></strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    <span style="color: #0000ff">var</span> text1 = document.createTextNode('文本1'); <span style="color: #008000">//</span><span style="color: #008000">创建一个文本节点</span>
    <span style="color: #0000ff">var</span> text2 = document.createTextNode('文本2'); <span style="color: #008000">//</span><span style="color: #008000">创建一个文本节点</span>
    sdf.appendChild(text1); <span style="color: #008000">//</span><span style="color: #008000">将新节点添加到sdf节点里子节点末尾</span>
    sdf.appendChild(text2); <span style="color: #008000">//</span><span style="color: #008000">将新节点添加到sdf节点里子节点末尾</span>
    alert(sdf.childNodes.length);  <span style="color: #008000">//</span><span style="color: #008000">查看元素节点里的子节点集合长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回2，说明是两个文本节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;文本1文本2&lt;/div&gt;</span>
    <span style="color: #008000">//</span><span style="color: #008000">注意：此时添加了两个文本节点，但是用眼睛看就像是一个文本节点，这里一点要注意<br><br></span>

    <span style="color: #008000">//</span><span style="color: #008000">normalize()合并同级的文本节点</span>
    sdf.normalize(); <span style="color: #008000">//</span><span style="color: #008000">将一个元素节点里的同级多个文本子节点，合并成一个文本子节点</span>
    alert(sdf.childNodes.length); <span style="color: #008000">//</span><span style="color: #008000">查看元素节点里的子节点集合长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：1 ，说明已经合并了</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>splitText()分离一个文本节点，参数是要分离的字符数</strong></span><br><strong>使用方式：</strong><br><strong>目标文本节点.splitText(分离几个字符)</strong></p>
<div class="cnblogs_code">
<pre>//&lt;div id="box" title="标题"&gt;这是一段文本&lt;/div&gt;</pre>
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    alert(sdf.childNodes.length);  <span style="color: #008000">//</span><span style="color: #008000">查看元素里的子节点长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：1 ，说明是一个文本子节点</span>
    alert(sdf.childNodes[0].nodeValue); <span style="color: #008000">//</span><span style="color: #008000">查看文本子节点内容</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段文本</span>

    <span style="color: #008000">//</span><span style="color: #008000">splitText()分离一个文本节点，参数是要分离的字符数</span>
    sdf.childNodes[0].splitText(3);  <span style="color: #008000">//</span><span style="color: #008000">将文本节点前3个字符分离成一个文本节点</span>
    alert(sdf.childNodes.length);  <span style="color: #008000">//</span><span style="color: #008000">查看元素里的子节点长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回2，说明已经分离了</span>
    alert(sdf.childNodes[0].nodeValue); <span style="color: #008000">//</span><span style="color: #008000">查看文本子节点内容</span>
};</pre>
</div>
<p><span style="color: #0000ff"><strong>&nbsp;Text还提供了一些别的DOM操作的方法如下：</strong></span></p>
<p><span style="color: #ff0000"><strong>deleteData()删除一个文本节点里指定范围的字符，参数是要删除字符的起始位置,和结束位置</strong></span><br><strong>使用方式：</strong><br><strong>目标文本节点.deleteData(起始位置,结束位置)</strong></p>
<div class="cnblogs_code">
<pre>//&lt;div id="box" title="标题"&gt;这是一段文本&lt;/div&gt;</pre>
<pre><br>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里子元素的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段文本</span>

    <span style="color: #008000">//</span><span style="color: #008000">deleteData()删除一个文本节点里指定范围的字符，参数是要删除字符的起始位置,和结束位置</span>
    sdf.childNodes[0].deleteData(0,3);  <span style="color: #008000">//</span><span style="color: #008000">删除文本节点里的指定文本，从0-3位置删除</span>
    alert(sdf.childNodes[0].nodeValue); <span style="color: #008000">//</span><span style="color: #008000">查看删除后的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：段文本</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>insertData()在文本节点里的指定位置添加指定文本内容</strong></span><br><strong>使用方式：</strong><br><strong>目标文本节点.insertData(要添加文本的字符位置,要添加的文本内容)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;这是一段文本&lt;/div&gt;<br><br></span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里子元素的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段文本</span>

    <span style="color: #008000">//</span><span style="color: #008000">insertData()在文本节点里的指定位置添加指定文本内容</span>
    sdf.childNodes[0].insertData(4,'测试'); <span style="color: #008000">//</span><span style="color: #008000">insertData()在文本节点里的指定位置添加指定文本内容</span>
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里子元素的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段测试文本  添加成功</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>replaceData()在文本节点里的指定范围替换成指定文本内容</strong></span><br><strong>使用方式：</strong><br><strong>目标文本节点.replaceData(要替换的起始范围位置,要替换几个字符,要替换的字符串)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;这是一段文本&lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里子元素的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段文本</span>

    <span style="color: #008000">//</span><span style="color: #008000">replaceData()在文本节点里的指定范围替换成指定文本内容</span>
    sdf.childNodes[0].replaceData(2,2,'测试'); 
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看替换后的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是测试文本</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>substringData()在文本节点里获取指定范围文本内容</strong></span><br><strong>使用方式：</strong><br><strong>目标文本节点.substringData(起始范围位置,获取几个字符)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;这是一段文本&lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> sdf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过id获取到标签</span>
    alert(sdf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里子元素的文本</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是一段文本</span>

    <span style="color: #008000">//</span><span style="color: #008000">substringData()在文本节点里获取指定范围文本内容</span>
    alert(sdf.childNodes[0].substringData(0,2)); <span style="color: #008000">//</span><span style="color: #008000">substringData()在文本节点里获取指定范围文本内容</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>5.Comment类型，html注释节点</strong></span></p>
<p align="left"><strong>Comment类型表示文档中的注释。nodeType是8，nodeName是#comment，nodeValue是注释的内容。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">&lt;div id="box" title="标题"&gt;&lt;!--这是注释--&gt;&lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">非IE获取注释节点</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取到注释的父节点</span>
    alert(asf.childNodes.length);  <span style="color: #008000">//</span><span style="color: #008000">查看节点里的子节点长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回1：说明就一个子节点</span>
    alert(asf.childNodes[0].nodeName);  <span style="color: #008000">//</span><span style="color: #008000">查看第一个子节点的标签名称</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：#comment 表示是标签名称</span>
    alert(asf.childNodes[0].nodeValue);  <span style="color: #008000">//</span><span style="color: #008000">查看第一个子节点的文本内容</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：这是注释</span>

    <span style="color: #008000">//</span><span style="color: #008000">低版本IE获取注释节点</span>
    <span style="color: #0000ff">var</span> asf2 = document.getElementsByName('!');  <span style="color: #008000">//</span><span style="color: #008000">通过标签名称获取到注释标签节点</span>
    alert(asf2.length);  <span style="color: #008000">//</span><span style="color: #008000">查看获取到的注释节点长度</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>6.Attr类型，标签属性类型</strong></span></p>
<p align="left"><strong>Attr类型表示文档元素中的属性。nodeType为2，nodeName为属性名，nodeValue为属性值。DOM基础篇已经详细介绍过，略。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><strong><span style="color: #ff0000">二．DOM扩展</span></strong></p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>1.呈现模式</strong></span></p>
<p align="left"><strong>从IE6开始开始区分标准模式和混杂模式(怪异模式)，主要是看文档的声明。IE为document对象添加了一个名为compatMode属性，这个属性可以识别IE浏览器的文档处于什么模式如果是标准模式，则返回CSS1Compat，如果是混杂模式则返回BackCompat。</strong></p>
<p align="left"><span style="color: #ff0000"><strong>compatMode属性，识别IE浏览器的文档处于什么模式，标准模式返回CSS1Compat，混杂模式返回BackCompat</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">compatMode属性，识别IE浏览器的文档处于什么模式，标准模式返回CSS1Compat，混杂模式返回BackCompat</span>
    alert(document.compatMode);  <span style="color: #008000">//</span><span style="color: #008000">查看IE浏览器的文档处于什么模式</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：CSS1Compat</span>

    <span style="color: #008000">//</span><span style="color: #008000">如果把html文档声明&lt;!DOCTYPE html&gt;删除了就是混杂模式</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：BackCompat</span>
};</pre>
</div>
<p><span style="color: #ff0000"><strong>clientWidth属性，查看节点元素的宽度</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">判断文档处于什么模式，如果是标准模式</span>
    <span style="color: #0000ff">if</span> (document.compatMode == 'CSS1Compat'<span style="color: #000000">) {
        </span><span style="color: #008000">//</span><span style="color: #008000">如果是标准模式，获取到html节点，查看它的宽度</span>
<span style="color: #000000">        alert(document.documentElement.clientWidth);
    } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
        </span><span style="color: #008000">//</span><span style="color: #008000">如果不是标准模式，获取到body标签节点，查看它的宽度</span>
<span style="color: #000000">        alert(document.body.clientWidth);
    }
};</span></pre>
</div>
<p align="left"><strong>后来Firefox、Opera和Chrome都实现了这个属性。从IE8后，又引入documentMode新属性，因为IE8有3种呈现模式分别为标准模式8，仿真模式7，混杂模式5。所以如果想测试IE8的标准模式，就判断document.documentMode &gt; 7 即可。</strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong>documentMode属性，<strong>识别IE浏览器的文档处于什么模式，<strong>标准模式8，仿真模式7，混杂模式5，返回数值</strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">documentMode属性，识别IE浏览器的文档处于什么模式，标准模式8，仿真模式7，混杂模式5，返回数值</span>
    <span style="color: #0000ff">if</span> (document.documentMode &lt;= 5<span style="color: #000000">) {
        alert(</span>'混杂模式'<span style="color: #000000">);
    }</span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(document.documentMode &lt;= 7<span style="color: #000000">){
        alert(</span>'仿真模式'<span style="color: #000000">);
    }</span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(document.documentMode &lt;= 8<span style="color: #000000">){
        alert(</span>'标准模式'<span style="color: #000000">);
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>2.滚动</strong></span></p>
<p align="left"><strong>DOM提供了一些滚动页面的方法，如下：</strong></p>
<p><span style="color: #ff0000"><strong>scrollIntoView()方法，将一个元素节点设置滚动在可见范围</strong></span><br><span style="color: #0000ff"><strong>注意：这里说的可见范围是这样的，比如目标节点在页面底部，而目标节点上面有很多类容，也就是目标节点超出浏览器范围不可见，要手动拖动滚动条才可见，scrollIntoView()方法可以定位滚动条到目标节点可见范围</strong></span></p>
<div class="cnblogs_code">
<pre>window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    document.getElementById('box').scrollIntoView();    <span style="color: #008000">//</span><span style="color: #008000">设置指定可见</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>3.children属性</strong></span></p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong><strong>children属性，获取一个元素节点里的子节点，自动过滤掉空白文本节点<strong>【推荐】</strong></strong></strong></span></p>
<p align="left"><strong>由于子节点空白问题，IE和其他浏览器解释不一致。虽然可以过滤掉，但如果只是想得到有效子节点，可以使用children属性，支持的浏览器为：IE5+、Firefox3.5+、Safari2+、Opera8+和Chrome，这个属性是非标准的。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');    <span style="color: #008000">//</span><span style="color: #008000">通过id获取到元素节点</span>
    alert(asf.children);  <span style="color: #008000">//</span><span style="color: #008000">children属性，获取一个元素节点里的子节点，自动过滤掉空白文本节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：[object HTMLCollection] 子节点集合对象</span>
    alert(asf.children.length);  <span style="color: #008000">//</span><span style="color: #008000">查看子节点的长度</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：3 ，已经自动过滤了空白文本子节点</span>

    <span style="color: #008000">//</span><span style="color: #008000">循环出所有子节点的标签名称和内容文本</span>
    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; asf.children.length; i ++){  <span style="color: #008000">//</span><span style="color: #008000">根据子节点长度循环次数</span>
        <span style="color: #008000">//</span><span style="color: #008000">每次循环打印出循环到的子节点标签名称和子节点标签文本内容</span>
        alert('标签名称：' + asf.children[i].nodeName + '-' + '标签文本内容：' +<span style="color: #000000"> asf.children[i].innerHTML);
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>4.contains()方法</strong></span></p>
<p><span style="color: #ff0000"><strong>contains()方法，判断一个节点是否是另外一个节点的子节点，返回布尔值</strong></span><br><strong>使用方式：</strong><br><strong>要判断的父节点.contains(要判断的子节点)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');    <span style="color: #008000">//</span><span style="color: #008000">通过id获取到元素节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">contains()方法，判断一个节点是否是另外一个节点的子节点，返回布尔值</span>
    alert(asf.contains(asf.children[0])); <span style="color: #008000">//</span><span style="color: #008000">判断asf节点里的第一个子节点是否是asf的子节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">true</span>
};</pre>
</div>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>PS：早期的Firefox不支持这个方法，新版的支持了，其他浏览器也都支持，Safari2.x浏览器支持的有问题，无法使用。所以，必须做兼容。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>在Firefox的DOM3级实现中提供了一个替代的方法compareDocumentPosition()方法。这个方法确定两个节点之间的关系。</strong></span></p>
<p><span style="color: #ff0000"><strong>compareDocumentPosition()方法，判断两个节点之间的关系，返回关系掩码</strong></span><br><strong>使用方式：</strong><br><strong>要判断的a节点.compareDocumentPosition(要判断的b节点)</strong></p>
<p align="center"><span style="color: #ff0000"><strong>关系掩码表</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="192">
<p align="center"><strong>掩码</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>节点关系</strong></p>









</td>









</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>1</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>无关(节点不存在)</strong></p>









</td>









</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>2</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>居前(节点在参考点之前)</strong></p>









</td>









</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>4</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>居后(节点在参考点之后)</strong></p>









</td>









</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>8</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>包含(节点是参考点的祖先)</strong></p>









</td>









</tr>
<tr>
<td valign="top" width="192">
<p align="center"><strong>16</strong></p>









</td>
<td valign="top" width="306">
<p align="center"><strong>被包含(节点是参考点的后代)</strong></p>









</td>









</tr>









</tbody>









</table>









</div>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');    <span style="color: #008000">//</span><span style="color: #008000">通过id获取到元素节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">compareDocumentPosition()方法，判断两个节点之间的关系，返回关系掩码</span>
    alert(asf.compareDocumentPosition(asf.children[0])); <span style="color: #008000">//</span><span style="color: #008000">判断asf节点里的第一个子节点与asf节点是什么关系</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回：20，</span>
    <span style="color: #008000">//</span><span style="color: #008000">为什么会出现20，那是因为满足了4和16两项，最后相加了</span>
};</pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>PS：为什么会出现20，那是因为满足了4和16两项，最后相加了。为了能让所有浏览器都可以兼容，我们必须写一个兼容性的函数。</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>contains()方法和compareDocumentPosition()方法的兼容方式</strong></span></p>
<p><span style="color: #ff0000"><strong>自定义一个判断两个节点关系的函数，<strong>判断一个节点是否是另外一个节点的子节点，返回布尔值</strong></strong></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>

<span style="color: #008000">//</span><span style="color: #008000">contains()方法和compareDocumentPosition()方法的兼容方式</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">首先创建两个节点，用于判断它们之间的关系</span>
    <span style="color: #0000ff">var</span> jd1 = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">获取到父节点</span>
    <span style="color: #0000ff">var</span> jd2 = jd1.children[0]; <span style="color: #008000">//</span><span style="color: #008000">获取到子节点</span>

    <span style="color: #008000">//</span><span style="color: #008000">执行判断两个节点关系函数</span>
<span style="color: #000000">    alert(containsjr(jd1,jd2));

    </span><span style="color: #008000">//</span><span style="color: #008000">自定义兼容函数</span>
    <span style="color: #0000ff">function</span> containsjr(jdx1,jdx2) {  <span style="color: #008000">//</span><span style="color: #008000">函数接收两个参数，第一个参数父节点，第二个参数子节点</span>
        <span style="color: #008000">//</span><span style="color: #008000">判断浏览器如果支持contains()方法 ，并且非Safari浏览器 ，导入浏览器检测模块browserdetect.js</span>
        <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> jdx1.contains != 'undefined' &amp;&amp; !(BrowserDetect.browser == 'Safari' &amp;&amp; BrowserDetect.version &lt; 3<span style="color: #000000">)){
            </span><span style="color: #008000">//</span><span style="color: #008000">返回contains()方法执行后的结果</span>
            <span style="color: #0000ff">return</span> jdx1.contains(jdx2); <span style="color: #008000">//</span><span style="color: #008000">contains()方法，判断一个节点是否是另外一个节点的子节点，返回布尔值</span>
        }<span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(<span style="color: #0000ff">typeof</span> jdx1.compareDocumentPosition == 'function'){  <span style="color: #008000">//</span><span style="color: #008000">判断浏览器如果支持compareDocumentPosition方法</span>
            <span style="color: #0000ff">return</span> jdx1.compareDocumentPosition(jdx2) &gt; 16; <span style="color: #008000">//</span><span style="color: #008000">compareDocumentPosition()方法，判断两个节点之间的关系，返回关系掩码</span>
        }<span style="color: #0000ff">else</span><span style="color: #000000"> {
            </span><span style="color: #008000">//</span><span style="color: #008000">更低的浏览器兼容，通过递归一个个获取他的父节点是否存在</span>
            <span style="color: #0000ff">var</span> node = jdx2.parentNode; <span style="color: #008000">//</span><span style="color: #008000">通过子节点获取父节点</span>
            <span style="color: #008000">//</span><span style="color: #008000">do...while语句是一种先运行，后判断的循环语句。也就是说，不管条件是否满足，至少先运行一次循环体。</span>
            <span style="color: #0000ff">do</span><span style="color: #000000"> {
                </span><span style="color: #0000ff">if</span> (node === jdx1){ <span style="color: #008000">//</span><span style="color: #008000">判断通过子节点获取到的父节点如果等于函数传参的父节点</span>
                    <span style="color: #0000ff">return</span> <span style="color: #0000ff">true</span><span style="color: #000000">;
                }</span><span style="color: #0000ff">else</span><span style="color: #000000"> {
                    node </span>= node.parentNode; <span style="color: #008000">//</span><span style="color: #008000">否则node变量等于父节点的父节点</span>
<span style="color: #000000">                }
            }</span><span style="color: #0000ff">while</span> (node != <span style="color: #0000ff">null</span><span style="color: #000000">);
            </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
        }
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>三．</strong><strong>DOM</strong><strong>操作内容</strong></span></p>
<p align="left"><strong>虽然在之前我们已经学习了各种DOM操作的方法，这里所介绍是innerText、innerHTML、outerText和outerHTML等属性。除了之前用过的innerHTML之外，其他三个还么有涉及到。</strong></p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>1.innerText属性【推荐】</strong></span></p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong><strong>innerText属性，设置或</strong></strong></span><span style="color: #ff0000"><strong>获取一个元素的文本内容，获取(如有html直接过滤掉)，</strong></span><span style="color: #ff0000"><strong><span style="font-size: 10.5pt; line-height: 1.5; font-family: 宋体">设置文本</span><span style="font-size: 10.5pt; line-height: 1.5; font-family: &quot;Times New Roman&quot;, serif" lang="EN-US">(</span><span style="font-size: 10.5pt; line-height: 1.5; font-family: 宋体">如有</span><span style="font-size: 10.5pt; line-height: 1.5; font-family: &quot;Times New Roman&quot;, serif" lang="EN-US">html</span><span style="font-size: 10.5pt; line-height: 1.5; font-family: 宋体">转义</span><span style="font-size: 10.5pt; line-height: 1.5; font-family: &quot;Times New Roman&quot;, serif" lang="EN-US">)</span></strong></span></p>
<p align="left"><span style="color: #000000"><strong><span style="font-size: 10.5pt; line-height: 1.5; font-family: &quot;Times New Roman&quot;, serif" lang="EN-US">使用方式：</span></strong></span></p>
<p align="left"><strong>目标节点.innerText</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    alert(asf.innerText);   <span style="color: #008000">//</span><span style="color: #008000">innerText属性，设置或获取一个元素的文本内容，获取(如有html直接过滤掉)，设置文本(如有html转义)</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试1</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试2</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试3</span>
    asf.innerText = '&lt;b&gt;修改&lt;/b&gt;';  <span style="color: #008000">//</span><span style="color: #008000">重新设置节点内容</span>
    alert(asf.innerText);  <span style="color: #008000">//</span><span style="color: #008000">重新查看节点内容</span>
    <span style="color: #008000">//</span><span style="color: #008000">&lt;b&gt;修改&lt;/b&gt;</span>
};</pre>
</div>
<p align="left"><strong><span style="text-indent: 28px; color: #333333" lang="EN-US">PS</span><span style="text-indent: 28px; font-family: 宋体; color: #333333">：除了</span><span style="text-indent: 28px; color: #333333" lang="EN-US">Firefox火狐浏览器</span><span style="text-indent: 28px; font-family: 宋体; color: #333333">之外，其他浏览器均支持这个方法。但</span><span style="text-indent: 28px; color: #333333" lang="EN-US">Firefox</span><span style="text-indent: 28px; font-family: 宋体; color: #333333">的</span><span style="text-indent: 28px; color: #333333" lang="EN-US">DOM3</span><span style="text-indent: 28px; font-family: 宋体; color: #333333">级提供了另外一个类似的属性：</span><span style="text-indent: 28px; color: #333333" lang="EN-US">textContent</span><span style="text-indent: 28px; font-family: 宋体; color: #333333">，做上兼容即可通用。</span></strong></p>
<p align="left"><span style="text-indent: 28px; color: #ff0000"><span style="font-family: 宋体"><strong>textContent属性(只有火狐支持)，设置或获取一个元素的文本内容，获取(如有html直接过滤掉)，设置文本(如有html转义)</strong></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    alert(asf.textContent);   <span style="color: #008000">//</span><span style="color: #008000">textContent属性，设置或获取一个元素的文本内容，获取(如有html直接过滤掉)，设置文本(如有html转义)</span>
    <span style="color: #008000">//</span><span style="color: #008000">返回</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试1</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试2</span>
    <span style="color: #008000">//</span><span style="color: #008000"> 测试3</span>
    asf.textContent = '&lt;b&gt;修改&lt;/b&gt;';  <span style="color: #008000">//</span><span style="color: #008000">重新设置节点内容</span>
    alert(asf.textContent);  <span style="color: #008000">//</span><span style="color: #008000">重新查看节点内容</span>
    <span style="color: #008000">//</span><span style="color: #008000">&lt;b&gt;修改&lt;/b&gt;</span>
};</pre>
</div>
<p align="left"><span style="color: #ff0000"><strong>&nbsp;innerText和textContent兼容方案</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    alert(getInnerText(asf)); <span style="color: #008000">//</span><span style="color: #008000">获取节点文本</span>
    setInnerText(asf,'&lt;b&gt;赋值&lt;/b&gt;'<span style="color: #000000">)
    alert(getInnerText(asf)); </span><span style="color: #008000">//</span><span style="color: #008000">获取节点文本</span>
<span style="color: #000000">
};

</span><span style="color: #008000">//</span><span style="color: #008000">兼容方案</span><span style="color: #008000">
//</span><span style="color: #008000">获取方案</span>
<span style="color: #0000ff">function</span> getInnerText(element) { <span style="color: #008000">//</span><span style="color: #008000">接收节点</span>
    <span style="color: #008000">//</span><span style="color: #008000">三元运算，判断节点的textContent类型等于string，执行element.textContent，否则执行element.innerText</span>
    <span style="color: #0000ff">return</span> (<span style="color: #0000ff">typeof</span> element.textContent == 'string') ?<span style="color: #000000"> element.textContent : element.innerText;
}

</span><span style="color: #008000">//</span><span style="color: #008000">设置方案</span>
<span style="color: #0000ff">function</span> setInnerText(element, text) { <span style="color: #008000">//</span><span style="color: #008000">接收节点，和要设置的字符串</span>
    <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> element.textContent == 'string'<span style="color: #000000">) {
        element.textContent </span>=<span style="color: #000000"> text;
    } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
        element.innerText </span>=<span style="color: #000000"> text;
    }
}</span></pre>
</div>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>2.innerHTML属性【推荐】</strong></span></p>
<p align="left"><span style="color: #ff0000; background-color: #ffffff"><strong><strong>innerHTML属性，获取节点里的文本内容，不过滤html</strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    alert(asf.innerHTML); <span style="color: #008000">//</span><span style="color: #008000">获取节点里的文本内容，不过滤html</span>
    asf.innerHTML = '&lt;b&gt;123&lt;/b&gt;'; <span style="color: #008000">//</span><span style="color: #008000">设置节点里的文本内容，可解析HTML</span>
    alert(asf.innerHTML); <span style="color: #008000">//</span><span style="color: #008000">//获取节点里的文本内容，不过滤html</span>
};</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #0000ff"><strong>PS：关于最常用的innerHTML属性和节点操作方法的比较，在插入大量HTML标记时使用innerHTML的效率明显要高很多。因为在设置innerHTML时，会创建一个HTML解析器。这个解析器是浏览器级别的(C++编写)，因此执行JavaScript会快的多。但，创建和销毁HTML解析器也会带来性能损失。最好控制在最合理的范围内，如下：</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; 10; i ++<span style="color: #000000">) {
ul.innerHTML </span>= '&lt;li&gt;item&lt;/li&gt;';            <span style="color: #008000">//</span><span style="color: #008000">避免频繁</span>
<span style="color: #000000">}
</span><span style="color: #008000">//</span><span style="color: #008000">改</span>
<span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; 10; i ++<span style="color: #000000">) {
a </span>= '&lt;li&gt;item&lt;/li&gt;';                        <span style="color: #008000">//</span><span style="color: #008000">临时保存</span>
<span style="color: #000000">}
ul.innerHTML </span>= a;</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #0000ff"><strong>虽然innerHTML可以插入HTML，但本身还是有一定的限制，也就是所谓的作用域元素，离开这个作用域就无效了</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    asf.innerHTML = "&lt;script&gt;alert('Lee');&lt;/script&gt;";    <span style="color: #008000">//</span><span style="color: #008000">&lt;script&gt;元素不能被执行</span>
    asf.innerHTML = "&lt;style&gt;background:red;&lt;/style&gt;";    <span style="color: #008000">//</span><span style="color: #008000">&lt;style&gt;元素不能被执行</span>
<span style="color: #000000">
};</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>3.outerText</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>outerText在取值的时候和innerText一样，同时火狐不支持，而赋值方法相当危险，他不单替换了文本内容，还将节点元素直接抹去。【不建议使用】</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    asf.outerText = '&lt;b&gt;123&lt;/b&gt;';  <span style="color: #008000">//</span><span style="color: #008000">给节设置文本内容</span>
    alert(document.getElementById('box'));            <span style="color: #008000">//</span><span style="color: #008000">null，建议不去使用</span>
<span style="color: #000000">
};</span></pre>
</div>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>4.outerHTML</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>outerHTML属性在取值和innerHTML一致，但和outerText也一样，很危险，赋值的之后会将元素抹去。<strong>【不建议使用】</strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> &lt;div id="box" title="标题"&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试1&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试2&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000">     &lt;p&gt;测试3&lt;/p&gt;</span><span style="color: #008000">
//</span><span style="color: #008000"> &lt;/div&gt;</span>
window.onload = <span style="color: #0000ff">function</span>() { <span style="color: #008000">//</span><span style="color: #008000">window.onload事件，等待html执行完成后，执行匿名函数</span>
    <span style="color: #0000ff">var</span> asf = document.getElementById('box');  <span style="color: #008000">//</span><span style="color: #008000">通过ID获取一个节点</span>
    asf.outerHTML = '123'; <span style="color: #008000">//</span><span style="color: #008000">设置节点文本内容</span>
    alert(document.getElementById('box'));            <span style="color: #008000">//</span><span style="color: #008000">null，建议不去使用，火狐旧版未抹去</span>
};</pre>
</div>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p></div>