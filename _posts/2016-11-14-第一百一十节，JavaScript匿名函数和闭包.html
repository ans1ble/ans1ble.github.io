第一百一十节，JavaScript匿名函数和闭包


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="font-size: 18pt; color: #0000ff"><strong>JavaScript匿名函数和闭包</strong></span></p>
<p align="left"><strong>学习要点：</strong></p>
<p align="left"><strong>1.匿名函数</strong></p>
<p align="left"><strong>2.闭包</strong></p>
<p><strong>匿名函数就是没有名字的函数，闭包是可访问一个函数作用域里变量的函数。声明：本节内容需要有面向对象和少量设计模式基础，否则无法听懂.(所需基础15章的时候已经声明过了)。</strong></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>一．</strong><strong>匿名函数</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>普通函数</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span> box() {                            <span style="color: #008000">//</span><span style="color: #008000">函数名是box</span>
    <span style="color: #0000ff">return</span> 'Lee'<span style="color: #000000">;
}

alert(box());</span><span style="color: #008000">//</span><span style="color: #008000">通过函数名称来执行函数</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>匿名函数</strong></span></p>
<p><span style="color: #0000ff"><strong>就是没有名称的函数</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">匿名函数</span>
<span style="color: #0000ff">function</span> () {                                <span style="color: #008000">//</span><span style="color: #008000">匿名函数，会报错</span>
    <span style="color: #0000ff">return</span> 'Lee'<span style="color: #000000">;
}
</span><span style="color: #008000">//</span><span style="color: #008000">匿名函数,因为没有名称所以无法执行，也就会报错</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>通过表达式自我执行匿名函数</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">通过表达式自我执行</span>
(<span style="color: #0000ff">function</span> box() {                            <span style="color: #008000">//</span><span style="color: #008000">用括号将函数体，封装成表达式，就是用一对括号将函数体括起来，</span>
    alert('Lee'<span style="color: #000000">);
})();                                        </span><span style="color: #008000">//</span><span style="color: #008000">最后用一个()表示执行函数，</span><span style="color: #008000">
//</span><span style="color: #008000">返回：Lee</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>用过变量执行匿名函数</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">把匿名函数赋值给变量</span>
<span style="color: #0000ff">var</span> box = <span style="color: #0000ff">function</span> () {                        <span style="color: #008000">//</span><span style="color: #008000">将匿名函数赋给变量</span>
    <span style="color: #0000ff">return</span> 'Lee'<span style="color: #000000">;
};
alert(box());                                </span><span style="color: #008000">//</span><span style="color: #008000">调用方式和函数调用相似，也就是通过变量名称加()执行函数</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong><span style="font-size: 10.5pt; font-family: 宋体">函数里的匿名函数，产生闭包</span></strong></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">函数里的匿名函数</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> box () {
    </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {                        <span style="color: #008000">//</span><span style="color: #008000">函数里的匿名函数，产生闭包</span>
        <span style="color: #0000ff">return</span> 'Lee'<span style="color: #000000">;
    }
}
</span><span style="color: #008000">//</span><span style="color: #008000">执行方式1</span>
alert(box()());                                <span style="color: #008000">//</span><span style="color: #008000">通过执行函数，在加上一对括号执行匿名函数</span>

<span style="color: #008000">//</span><span style="color: #008000">执行方式2</span>
<span style="color: #0000ff">var</span> asdf = box();   <span style="color: #008000">//</span><span style="color: #008000">将执行函数赋值给一个变量，</span>
alert(asdf());    <span style="color: #008000">//</span><span style="color: #008000">在通过变量在执行里面匿名函数</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left"><span style="color: #ff0000"><strong><span lang="EN-US">二．</span></strong></span><strong><span style="font-family: 宋体; color: #ff0000">闭包，<span style="font-size: 18pt">是在<strong>函数里返回匿名函数【重点】</strong></span></span></strong></p>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left"><strong><span style="font-family: 宋体; color: #333333">闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</span></strong></p>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left">&nbsp;</p>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left"><span style="color: #ff0000"><span style="font-family: 宋体"><strong>通过闭包可以返回局部变量</strong></span></span></p>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left">&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">通过闭包可以返回局部变量</span>
<span style="color: #0000ff">function</span> box() {           <span style="color: #008000">//</span><span style="color: #008000">创建box函数</span>
    <span style="color: #0000ff">var</span> user = 'Lee';       <span style="color: #008000">//</span><span style="color: #008000">函数里有一个局部变量</span>
    <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {    <span style="color: #008000">//</span><span style="color: #008000">通过匿名函数返回box()局部变量</span>
        <span style="color: #0000ff">return</span> user;     <span style="color: #008000">//</span><span style="color: #008000">返回box()局部变量</span>
<span style="color: #000000">    };
}
alert(box()());                                </span><span style="color: #008000">//</span><span style="color: #008000">通过box()()来直接调用匿名函数返回值</span>

<span style="color: #0000ff">var</span> b =<span style="color: #000000"> box();
alert(b());                                    </span><span style="color: #008000">//</span><span style="color: #008000">另一种方式调用匿名函数返回值</span><span style="color: #008000">
//</span><span style="color: #008000">返回Lee</span></pre>
</div>
<p class="MsoNormal" style="margin-left: 0cm; text-indent: 0cm" align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>闭包优点和缺点</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>闭包可以把局部变量驻留在内存中</strong></span></p>
<p align="left"><strong>使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使用全局变量。(全局变量污染导致应用程序不可预测性，每个模块都可调用必将引来灾难，所以推荐使用私有的，封装的局部变量)。</strong>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">通过全局变量来累加</span>
<span style="color: #0000ff">var</span> age = 100;                                <span style="color: #008000">//</span><span style="color: #008000">全局变量</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> box1() {
    age </span>++;                                <span style="color: #008000">//</span><span style="color: #008000">模块级可以调用全局变量，进行累加</span>
<span style="color: #000000">}
box1();                                    </span><span style="color: #008000">//</span><span style="color: #008000">执行函数，累加了</span>
alert(age);                                <span style="color: #008000">//</span><span style="color: #008000">输出全局变量</span><span style="color: #008000">
//</span><span style="color: #008000">101</span>
box1();                                    <span style="color: #008000">//</span><span style="color: #008000">执行函数，累加了</span>
alert(age);                                <span style="color: #008000">//</span><span style="color: #008000">输出全局变量</span><span style="color: #008000">
//</span><span style="color: #008000">102</span>
box1();                                    <span style="color: #008000">//</span><span style="color: #008000">执行函数，累加了</span>
alert(age);                                <span style="color: #008000">//</span><span style="color: #008000">输出全局变量</span><span style="color: #008000">
//</span><span style="color: #008000">103</span>

<span style="color: #008000">//</span><span style="color: #008000">通过局部变量无法实现累加</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> box2() {
    </span><span style="color: #0000ff">var</span> age = 100;                      <span style="color: #008000">//</span><span style="color: #008000">局部变量</span>
    age ++;                                <span style="color: #008000">//</span><span style="color: #008000">累加</span>
    <span style="color: #0000ff">return</span><span style="color: #000000"> age;
}

alert(box2());                                </span><span style="color: #008000">//</span><span style="color: #008000">101</span>
alert(box2());                                <span style="color: #008000">//</span><span style="color: #008000">101，无法实现，因为又被初始化了</span>

<span style="color: #008000">//</span><span style="color: #008000">通过闭包可以实现局部变量的累加，闭包可以把局部变量驻留在内存中</span>
<span style="color: #0000ff">function</span> box() {        <span style="color: #008000">//</span><span style="color: #008000">创建函数</span>
    <span style="color: #0000ff">var</span> age = 100;      <span style="color: #008000">//</span><span style="color: #008000">局部变量</span>
    <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {    <span style="color: #008000">//</span><span style="color: #008000">创建闭包匿名函数</span>
        age ++;         <span style="color: #008000">//</span><span style="color: #008000">局部变量++</span>
        <span style="color: #0000ff">return</span> age;    <span style="color: #008000">//</span><span style="color: #008000">返回累加后的局部变量</span>
<span style="color: #000000">    }
}
</span><span style="color: #0000ff">var</span> b = box();                                <span style="color: #008000">//</span><span style="color: #008000">获得函数</span>
alert(b());                                    <span style="color: #008000">//</span><span style="color: #008000">调用匿名函数</span>
alert(b());                                    <span style="color: #008000">//</span><span style="color: #008000">第二次调用匿名函数，实现累加</span></pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>PS：由于闭包里作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存。过度使用闭包会导致性能下降，建议在非常有必要的时候才使用闭包。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>循环里包含匿名函数，出现问题</strong></span></p>
<p align="left"><strong>作用域链的机制导致一个问题，在循环中里的匿名函数取得的任何变量都是最后一个值。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">循环里包含匿名函数</span>
<span style="color: #0000ff">function</span> box() {      <span style="color: #008000">//</span><span style="color: #008000">创建函数</span>
    <span style="color: #0000ff">var</span> arr = [];    <span style="color: #008000">//</span><span style="color: #008000">创建一个空数组</span>

    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; 5; i++) {    <span style="color: #008000">//</span><span style="color: #008000">循环5次</span>
        arr[i] = <span style="color: #0000ff">function</span> () {      <span style="color: #008000">//</span><span style="color: #008000">每次循环将匿名函数的返回值，通过数组下标方式添加到数组</span>
            <span style="color: #0000ff">return</span><span style="color: #000000"> i;
        };
    }
    </span><span style="color: #0000ff">return</span> arr; <span style="color: #008000">//</span><span style="color: #008000">最后返回添加后的数组</span>
<span style="color: #000000">}

</span><span style="color: #0000ff">var</span> b = box();                                <span style="color: #008000">//</span><span style="color: #008000">得到函数返回的数组</span>
alert(b.length);                            <span style="color: #008000">//</span><span style="color: #008000">得到函数数组的长度</span>
<span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; b.length; i++) {        <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度，循环次数</span>
    alert(b[i]());                            <span style="color: #008000">//</span><span style="color: #008000">输出每个函数的值，都是最后一个值，因为在执行函数时就已经循环完了，最终得到的都是5</span>
}</pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>上面的例子输出的结果都是5，也就是循环后得到的最大的i值。因为b[i]调用的是匿名函数，匿名函数并没有自我执行，等到调用的时候，box()已执行完毕，i早已变成5，所以最终的结果就是5个5。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>循环里包含匿名函数-改1，自我执行匿名函数</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">循环里包含匿名函数-改1，自我执行匿名函数</span>
<span style="color: #0000ff">function</span> box() {   <span style="color: #008000">//</span><span style="color: #008000">创建函数</span>
    <span style="color: #0000ff">var</span> arr = [];  <span style="color: #008000">//</span><span style="color: #008000">函数里创建一个空数组</span>

    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; 5; i++) {    <span style="color: #008000">//</span><span style="color: #008000">循环5次</span>
        arr[i] = (<span style="color: #0000ff">function</span> (num) {        <span style="color: #008000">//</span><span style="color: #008000">每次循环自我执行匿名函数，得到匿名函数的返回值，将返回值通过数组下标添加到数组</span>
            <span style="color: #0000ff">return</span><span style="color: #000000"> num;
        })(i);                            </span><span style="color: #008000">//</span><span style="color: #008000">每次执行匿名函数，并且将每次循环的i传入匿名函数</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">return</span> arr;  <span style="color: #008000">//</span><span style="color: #008000">最后返回数组</span>
<span style="color: #000000">}

</span><span style="color: #0000ff">var</span> b = box();      <span style="color: #008000">//</span><span style="color: #008000">执行函数得到，数组</span>
<span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; b.length; i++) {   <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度来循环次数</span>
    alert(b[i]);                            <span style="color: #008000">//</span><span style="color: #008000">每次循环通过数组下标，来打印数组里的元素</span>
<span style="color: #000000">}
</span><span style="color: #008000">//</span><span style="color: #008000">返回</span><span style="color: #008000">
//</span><span style="color: #008000">0</span><span style="color: #008000">
//</span><span style="color: #008000">1</span><span style="color: #008000">
//</span><span style="color: #008000">2</span><span style="color: #008000">
//</span><span style="color: #008000">3</span><span style="color: #008000">
//</span><span style="color: #008000">4</span></pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>改1中，我们让匿名函数进行自我执行，导致最终返回给a[i]的是数组而不是函数了。最终导致b[0]-b[4]中保留了0,1,2,3,4的值。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>循环里包含匿名函数-改2，匿名函数下再做个匿名函数（<strong>闭包</strong>）</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">循环里包含匿名函数-改2，匿名函数下再做个匿名函数</span>
<span style="color: #0000ff">function</span> box() {     <span style="color: #008000">//</span><span style="color: #008000">创建函数</span>
    <span style="color: #0000ff">var</span> arr = [];    <span style="color: #008000">//</span><span style="color: #008000">函数里创建数组</span>

    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; 5; i++) {   <span style="color: #008000">//</span><span style="color: #008000">循环5次</span>
        arr[i] = (<span style="color: #0000ff">function</span> (num) {    <span style="color: #008000">//</span><span style="color: #008000">自我执行匿名函数，将每次循环的i传到匿名函数1，</span>
            <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {      <span style="color: #008000">//</span><span style="color: #008000">匿名函数2直接返回值i的值，函数里的函数闭包，闭包可以将i驻留在内存</span>
                <span style="color: #0000ff">return</span> num;                <span style="color: #008000">//</span><span style="color: #008000">原理和改1一样</span>
<span style="color: #000000">            }
        })(i);                      </span><span style="color: #008000">//</span><span style="color: #008000">执行匿名函数，并将i传入匿名函数</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">return</span> arr;  <span style="color: #008000">//</span><span style="color: #008000">返回数组</span>
<span style="color: #000000">}

</span><span style="color: #0000ff">var</span> b = box();  <span style="color: #008000">//</span><span style="color: #008000">执行函数，得到数组</span>
<span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; b.length; i++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度来循环次数</span>
    alert(b[i]());                    <span style="color: #008000">//</span><span style="color: #008000">通过数组的下标来获取数组的元素</span>
<span style="color: #000000">}
</span><span style="color: #008000">//</span><span style="color: #008000">返回</span><span style="color: #008000">
//</span><span style="color: #008000">0</span><span style="color: #008000">
//</span><span style="color: #008000">1</span><span style="color: #008000">
//</span><span style="color: #008000">2</span><span style="color: #008000">
//</span><span style="color: #008000">3</span><span style="color: #008000">
//</span><span style="color: #008000">4</span></pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>改1和改2中，我们通过匿名函数自我执行，立即把结果赋值给a[i]。每一个i，是调用方通过按值传递的，所以最终返回的都是指定的递增的i。而不是box()函数里的i。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>关于this对象，也就是<strong>this作用域在对象闭包里的情况</strong></strong></span></p>
<p align="left"><strong>在闭包中使用this对象也可能会导致一些问题，this对象是在运行时基于函数的执行环境绑定的，如果this在全局范围就是window，如果在对象内部就指向这个对象。<span style="color: #0000ff">而闭包却在运行时指向window作用域的，因为闭包并不属于这个对象的属性或方法。</span></strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong><strong>this作用域在对象闭包里，作用域指向的<strong>window全局</strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> user = 'The Window';  <span style="color: #008000">//</span><span style="color: #008000">全局变量创建字符串</span>

<span style="color: #0000ff">var</span> obj = {    <span style="color: #008000">//</span><span style="color: #008000">创建对象</span>
    user : 'The Object',  <span style="color: #008000">//</span><span style="color: #008000">添加一个对象属性</span>
    getUserFunction : <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">添加一个对象方法</span>
        <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {                    <span style="color: #008000">//</span><span style="color: #008000">返回闭包，闭包不属于obj，里面的this指向window</span>
            <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>.user;   <span style="color: #008000">//</span><span style="color: #008000">这里的this指向window作用域，那么就是全局变量user</span>
<span style="color: #000000">        };
    }
};

alert(obj.getUserFunction()());        </span><span style="color: #008000">//</span><span style="color: #008000">打印对象里的getUserFunction方法，返回的是全局变量user</span><span style="color: #008000">
//</span><span style="color: #008000">返回：The Window</span>

<span style="color: #008000">//</span><span style="color: #008000">可以强制指向某个对象，用对象冒充，将自己传入冒充方法里，冒充自己，这样this就指向了对象本身</span>
alert(obj.getUserFunction().call(obj));            <span style="color: #008000">//</span><span style="color: #008000">The Object</span><span style="color: #008000">
//</span><span style="color: #008000">返回：The Object</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>将作用域在对象闭包里，强制指向对象</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> user = 'The Window';  <span style="color: #008000">//</span><span style="color: #008000">全局变量创建字符串</span>

<span style="color: #0000ff">var</span> obj = {    <span style="color: #008000">//</span><span style="color: #008000">创建对象</span>
    user : 'The Object',  <span style="color: #008000">//</span><span style="color: #008000">添加一个对象属性</span>
    getUserFunction : <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">添加一个对象方法</span>
        <span style="color: #0000ff">var</span> zyy = <span style="color: #0000ff">this</span>;    <span style="color: #008000">//</span><span style="color: #008000">创建一个变量等于作用域，这里的作用域在闭包外，就是指向的对象本身</span>
        <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> () {                    <span style="color: #008000">//</span><span style="color: #008000">返回闭包，闭包不属于obj</span>
            <span style="color: #0000ff">return</span> zyy.user;   <span style="color: #008000">//</span><span style="color: #008000">这里使用zyy变量作用域，这样就强制将作用域指向对象</span>
<span style="color: #000000">        };
    }
};

alert(obj.getUserFunction()());        </span><span style="color: #008000">//</span><span style="color: #008000">打印对象里的getUserFunction方法，返回的是对象里的user属性</span><span style="color: #008000">
//</span><span style="color: #008000">返回：The Object</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>内存泄漏，也就是无法销毁驻留在内存中的元素</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>也就是在使用完后用null; 解除引用，进行回收</strong></span></p>
<p align="left"><strong>由于IE的JScript对象和DOM对象使用不同的垃圾收集方式，因此闭包在IE中会导致一些问题。就是内存泄漏的问题，也就是无法销毁驻留在内存中的元素。以下代码有两个知识点还没有学习到，一个是DOM，一个是事件。</strong></p>
<p align="left">&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span><span style="color: #000000"> box() {
    </span><span style="color: #0000ff">var</span> oDiv = document.getElementById('oDiv');    <span style="color: #008000">//</span><span style="color: #008000">oDiv用完之后一直驻留在内存</span>
    oDiv.onclick = <span style="color: #0000ff">function</span><span style="color: #000000"> () {
        alert(oDiv.innerHTML);                    </span><span style="color: #008000">//</span><span style="color: #008000">这里用oDiv导致内存泄漏</span>
<span style="color: #000000">    };
}
box();

那么在最后应该将oDiv解除引用来避免内存泄漏。
</span><span style="color: #0000ff">function</span><span style="color: #000000"> box() {
    </span><span style="color: #0000ff">var</span> oDiv = document.getElementById('oDiv'<span style="color: #000000">);    
</span><span style="color: #0000ff">var</span> text =<span style="color: #000000"> oDiv.innerHTML;
    oDiv.onclick </span>= <span style="color: #0000ff">function</span><span style="color: #000000"> () {
        alert(text);                    
    };
oDiv </span>= <span style="color: #0000ff">null</span>;                                <span style="color: #008000">//</span><span style="color: #008000">解除引用</span>
}</pre>
</div>
<p align="left">&nbsp;</p>
<p align="left"><strong>PS：如果并没有使用解除引用，那么需要等到浏览器关闭才得以释放。</strong></p>
<p align="left"><strong><span style="color: #0000ff">&nbsp;</span></strong></p>
<p align="left"><span style="color: #ff0000"><strong>匿名函数私有化</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>模仿块级作用域</strong></span></p>
<p align="left"><strong>JavaScript没有块级作用域的概念。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span> box1(count) {     <span style="color: #008000">//</span><span style="color: #008000">创建一个函数</span>
    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i=0; i&lt;count; i++) {} <span style="color: #008000">//</span><span style="color: #008000">根据传参进行循环次数</span>
    alert(i);                    <span style="color: #008000">//</span><span style="color: #008000">打印i,i不会因为离开了for块就失效,</span>
<span style="color: #000000">}
box1(</span>2<span style="color: #000000">);
</span><span style="color: #008000">//</span><span style="color: #008000">返回;2</span>

<span style="color: #0000ff">function</span> box2(count) {  <span style="color: #008000">//</span><span style="color: #008000">创建一个函数</span>
    <span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i=0; i&lt;count; i++) {}  <span style="color: #008000">//</span><span style="color: #008000">根据传参进行循环次数</span>
    <span style="color: #0000ff">var</span> i;                                <span style="color: #008000">//</span><span style="color: #008000">就算重新声明一个i变量</span>
    alert(i);                          <span style="color: #008000">//</span><span style="color: #008000">就算重新声明一个i变量，也能打印i</span>
<span style="color: #000000">}
box2(</span>2<span style="color: #000000">);
</span><span style="color: #008000">//</span><span style="color: #008000">返回：2</span></pre>
</div>
<p align="left"><strong>以上两个例子，说明JavaScript没有块级语句的作用域，if () {} for () {}等没有作用域，如果有，出了这个范围i就应该被销毁了。就算重新声明同一个变量也不会改变它的值。</strong></p>
<p align="left"><strong>JavaScript不会提醒你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见(如果初始化了，当然还会执行的)。使用模仿块级作用域可避免这个问题。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>模仿块级作用域(私有作用域)</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>就是将要私有的变量或者函数写在匿名函数里，这样就私有了</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>列1</strong></span></p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff">function</span><span style="color: #000000"> () {
    </span><span style="color: #008000">//</span><span style="color: #008000">这里是块级作用域</span>
})();</pre>
</div>
<p><span style="color: #0000ff"><strong>列2</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">使用块级作用域(私有作用域)改写</span>
<span style="color: #0000ff">function</span><span style="color: #000000"> box(count) {
    (</span><span style="color: #0000ff">function</span><span style="color: #000000"> () {
        </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i&lt;count; i++<span style="color: #000000">) {}
    })();
    alert(i);                                </span><span style="color: #008000">//</span><span style="color: #008000">报错，无法访问</span>
<span style="color: #000000">}
box(</span>2);</pre>
</div>
<p align="left"><strong>使用了块级作用域(私有作用域)后，匿名函数中定义的任何变量，都会在执行结束时被销毁。这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽可能少向全局作用域中添加变量和函数。在大型项目中，多人开发的时候，过多的全局变量和函数很容易导致命名冲突，引起灾难性的后果。如果采用块级作用域(私有作用域)，每个开发者既可以使用自己的变量，又不必担心搞乱全局作用域。</strong></p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff">function</span><span style="color: #000000"> () {
    </span><span style="color: #0000ff">var</span> box = [1,2,3,4<span style="color: #000000">];
    alert(box);                            </span><span style="color: #008000">//</span><span style="color: #008000">box出来就不认识了</span>
})();</pre>
</div>
<p align="left"><strong>在全局作用域中使用块级作用域可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>私有变量</strong></span></p>
<p align="left"><strong>JavaScript没有私有属性的概念；所有的对象属性都是公有的。不过，却有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span><span style="color: #000000"> box() {
    </span><span style="color: #0000ff">var</span> age = 100;                            <span style="color: #008000">//</span><span style="color: #008000">私有变量，外部无法访问</span>
}</pre>
</div>
<p align="left"><span style="color: #ff0000"><strong>而通过函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，可以创建用于访问私有变量的公有方法。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span><span style="color: #000000"> Box() {
    </span><span style="color: #0000ff">var</span> age = 100;                            <span style="color: #008000">//</span><span style="color: #008000">私有变量</span>
    <span style="color: #0000ff">function</span> run() {                        <span style="color: #008000">//</span><span style="color: #008000">私有函数</span>
        <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
    </span><span style="color: #0000ff">this</span>.get = <span style="color: #0000ff">function</span> () {                    <span style="color: #008000">//</span><span style="color: #008000">对外公共的特权方法</span>
        <span style="color: #0000ff">return</span> age +<span style="color: #000000"> run();
    };
}

</span><span style="color: #0000ff">var</span> box = <span style="color: #0000ff">new</span><span style="color: #000000"> Box();
alert(box.get());</span></pre>
</div>
<p align="left"><span style="color: #ff0000"><strong>可以通过构造方法传参来访问私有变量。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span> Person(value) {   <span style="color: #008000">//</span><span style="color: #008000">构造对象函数</span>
    <span style="color: #0000ff">var</span> user = value;                        <span style="color: #008000">//</span><span style="color: #008000">这句其实可以省略</span>
    <span style="color: #0000ff">this</span>.getUser = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">添加对象方法</span>
        <span style="color: #0000ff">return</span> user;   <span style="color: #008000">//</span><span style="color: #008000">返回user对象</span>
<span style="color: #000000">    };
    </span><span style="color: #0000ff">this</span>.setUser = <span style="color: #0000ff">function</span> (value) {  <span style="color: #008000">//</span><span style="color: #008000">添加对象方法接收一个参数</span>
        user = value;  <span style="color: #008000">//</span><span style="color: #008000">返回传参</span>
<span style="color: #000000">    };
}
</span><span style="color: #0000ff">var</span> person = <span style="color: #0000ff">new</span> Person('变量'); <span style="color: #008000">//</span><span style="color: #008000">实列化对象</span>
alert(person.getUser()); <span style="color: #008000">//</span><span style="color: #008000">打印对象里的getUser()方法</span><span style="color: #008000">
//</span><span style="color: #008000">返回：变量</span></pre>
</div>
<p align="left"><strong>但是对象的方法，在多次调用的时候，会多次创建。可以使用静态私有变量来避免这个问题。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>静态私有变量</strong></span></p>
<p align="left"><strong>通过块级作用域(私有作用域)中定义私有变量或函数，同样可以创建对外公共的特权方法。</strong></p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff">function</span> () {   <span style="color: #008000">//</span><span style="color: #008000">创建一个自我执行匿名函数</span>
    <span style="color: #0000ff">var</span> age = 100;   <span style="color: #008000">//</span><span style="color: #008000">私有变量</span>
    <span style="color: #0000ff">function</span> run() {   <span style="color: #008000">//</span><span style="color: #008000">私有函数</span>
        <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
    Box </span>= <span style="color: #0000ff">function</span> () {};                    <span style="color: #008000">//</span><span style="color: #008000">构造方法</span>
    Box.prototype.go = <span style="color: #0000ff">function</span> () {            <span style="color: #008000">//</span><span style="color: #008000">原型方法</span>
        <span style="color: #0000ff">return</span> age + run();  <span style="color: #008000">//</span><span style="color: #008000">返回私有变量加私有函数</span>
<span style="color: #000000">    };
})();


</span><span style="color: #0000ff">var</span> box = <span style="color: #0000ff">new</span> Box(); <span style="color: #008000">//</span><span style="color: #008000">实列化对象</span>
alert(box.go()); <span style="color: #008000">//</span><span style="color: #008000">打印对象里的go方法</span></pre>
</div>
<p><strong>上面的对象声明，采用的是Box = function () {} 而不是function Box() {} 因为如果用后面这种，就变成私有函数了，无法在全局访问到了，所以使用了前面这种。</strong></p>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>使用了prototype导致方法共享了，而user也就变成静态属性了。(所谓静态属性，即共享于不同对象中的属性)。</strong></span></p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">创建自我执行匿名函数</span>
    <span style="color: #0000ff">var</span> user = '';   <span style="color: #008000">//</span><span style="color: #008000">创建私有变量等于空字符串</span>
    Person = <span style="color: #0000ff">function</span> (value) {      <span style="color: #008000">//</span><span style="color: #008000">创建全局构造对象函数</span>
        user = value;   <span style="color: #008000">//</span><span style="color: #008000">将对象传参重新赋值给私有变量</span>
<span style="color: #000000">    };
    Person.prototype.getUser </span>= <span style="color: #0000ff">function</span> () { <span style="color: #008000">//</span><span style="color: #008000">创建原型方法</span>
        <span style="color: #0000ff">return</span> user; <span style="color: #008000">//</span><span style="color: #008000">返回私有变量</span>
<span style="color: #000000">    };
    Person.prototype.setUser2 </span>= <span style="color: #0000ff">function</span> (value) {  <span style="color: #008000">//</span><span style="color: #008000">创建原型方法接收一个参数</span>
        user = value;  <span style="color: #008000">//</span><span style="color: #008000">将传参赋值给私有变量</span>
        <span style="color: #0000ff">return</span><span style="color: #000000"> user;
    }
})();

</span><span style="color: #0000ff">var</span> abdc = <span style="color: #0000ff">new</span> Person('变量');<span style="color: #008000">//</span><span style="color: #008000">实列化对象</span>
alert(abdc.getUser()); <span style="color: #008000">//</span><span style="color: #008000">打印对象里的方法</span>
alert(abdc.setUser2('变量2'));</pre>
</div>
<p align="left"><strong>使用了prototype导致方法共享了，而user也就变成静态属性了。(所谓静态属性，即共享于不同对象中的属性)。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>模块模式</strong></span></p>
<p align="left"><strong>之前采用的都是构造函数的方式来创建私有变量和特权方法。那么对象字面量方式就采用模块模式来创建。</strong></p>
<p align="left"><span style="color: #0000ff"><strong>列1</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> box = {                                <span style="color: #008000">//</span><span style="color: #008000">字面量对象，也是单例对象</span>
    age : 100,                             <span style="color: #008000">//</span><span style="color: #008000">这是公有属性，将要改成私有</span>
    run : <span style="color: #0000ff">function</span> () {                    <span style="color: #008000">//</span><span style="color: #008000">这是公有函数，将要改成私有</span>
        <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
};</span></pre>
</div>
<p><span style="color: #0000ff"><strong>列2</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">私有化变量和函数：</span>
<span style="color: #0000ff">var</span> box = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">创建一个自我执行函数</span>
    <span style="color: #0000ff">var</span> age = 100;  <span style="color: #008000">//</span><span style="color: #008000">私有变量</span>
    <span style="color: #0000ff">function</span> run() {  <span style="color: #008000">//</span><span style="color: #008000">私有函数</span>
        <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
    </span><span style="color: #0000ff">return</span> {                                <span style="color: #008000">//</span><span style="color: #008000">直接返回对象</span>
        go : <span style="color: #0000ff">function</span> () {     <span style="color: #008000">//</span><span style="color: #008000">创建一个对象方法</span>
            <span style="color: #0000ff">return</span> age + run();  <span style="color: #008000">//</span><span style="color: #008000">返回私有变量加私有函数</span>
<span style="color: #000000">        }
    };
}();

alert(box.go());  </span><span style="color: #008000">//</span><span style="color: #008000">打印box函数里的go方法</span></pre>
</div>
<p align="left"><span style="color: #ff0000"><strong>上面的直接返回对象的例子，也可以这么写：</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> box = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">自我执行函数</span>
    <span style="color: #0000ff">var</span> age = 100;   <span style="color: #008000">//</span><span style="color: #008000">私有变量</span>
    <span style="color: #0000ff">function</span> run() {  <span style="color: #008000">//</span><span style="color: #008000">私有函数</span>
        <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
    </span><span style="color: #0000ff">var</span> obj =  {                            <span style="color: #008000">//</span><span style="color: #008000">创建字面量对象</span>
        go : <span style="color: #0000ff">function</span> () {   <span style="color: #008000">//</span><span style="color: #008000">创建对象方法</span>
            <span style="color: #0000ff">return</span> age + run();  <span style="color: #008000">//</span><span style="color: #008000">返回私有变量加私有方法</span>
<span style="color: #000000">        }
    };
    </span><span style="color: #0000ff">return</span> obj;                            <span style="color: #008000">//</span><span style="color: #008000">最后返回这个对象</span>
<span style="color: #000000">}();

alert(box.go());</span></pre>
</div>
<p align="left"><strong>字面量的对象声明，其实在设计模式中可以看作是一种单例模式，所谓单例模式，就是永远保持对象的一个实例。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>增强的模块模式，这种模式适合返回自定义对象，也就是构造函数。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">function</span> Desk(){};   <span style="color: #008000">//</span><span style="color: #008000">创建一个对象函数</span>
<span style="color: #0000ff">var</span> box = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">创建一个自我执行函数</span>
    <span style="color: #0000ff">var</span> age = 100;  <span style="color: #008000">//</span><span style="color: #008000">创建私有变量</span>
    <span style="color: #0000ff">function</span> run() {  <span style="color: #008000">//</span><span style="color: #008000">创建私有函数</span>
    <span style="color: #0000ff">return</span> '运行中...'<span style="color: #000000">;
    }
    </span><span style="color: #0000ff">var</span> desk = <span style="color: #0000ff">new</span> Desk();        <span style="color: #008000">//</span><span style="color: #008000">实列化构造对象函数</span>
    desk.go = <span style="color: #0000ff">function</span> () {   <span style="color: #008000">//</span><span style="color: #008000">向对象添加一个方法</span>
        <span style="color: #0000ff">return</span> age + run(); <span style="color: #008000">//</span><span style="color: #008000">返回私有变量加私有函数</span>
<span style="color: #000000">    };
    </span><span style="color: #0000ff">return</span> desk; <span style="color: #008000">//</span><span style="color: #008000">最后返回这个对象实列</span>
<span style="color: #000000">}();
alert(box.go()); </span><span style="color: #008000">//</span><span style="color: #008000">打印对象里go()方法</span></pre>
</div>
<p>&nbsp;</p></div>