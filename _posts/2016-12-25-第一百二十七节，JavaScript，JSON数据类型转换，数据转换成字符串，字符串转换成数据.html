第一百二十七节，JavaScript，JSON数据类型转换，数据转换成字符串，字符串转换成数据


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #0000ff"><strong><span style="font-size: 18pt">第一百二十七节，JavaScript，JSON数据类型转换，数据转换成字符串，字符串转换成数据</span></strong></span></p>
<p>&nbsp;</p>
<p align="left"><strong>学习要点：</strong></p>
<p align="left"><strong>1.JSON语法</strong></p>
<p align="left"><strong>2.解析和序列化</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><strong>前两章我们探讨了XML的结构化数据，但开发人员还是觉得这种微型的数据结构还是过于烦琐、冗长。为了解决这个问题，JSON的结构化数据出现了。JSON是JavaScript的一个严格的子集，利用JavaScript中的一些模式来表示结构化数据。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>一．</strong><strong>JSON</strong><strong>语法</strong></span></p>
<p align="left"><strong>JSON和XML类型，都是一种结构化的数据表示方式。所以，JSON并不是JavaScript独有的数据格式，其他很多语言都可以对JSON进行解析和序列化。</strong></p>
<p>&nbsp;</p>
<p align="left"><strong><span style="color: #ff0000">JSON的语法可以表示三种类型的值：</span></strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff00ff"><strong>1.简单值：可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持JavaScript中的特殊值undefined。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff00ff"><strong>2.对象：顾名思义。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff00ff"><strong>3.数组：顾名思义。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>简单值<strong>JSON表示</strong></strong></span></p>
<p align="left"><strong>100、"Lee" 这两个量就是JSON的表示方法，一个是JSON数值，一个是JSON字符串。布尔值和null也是有效的形式。但实际运用中要结合对象或数组。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">json简单值表示方式</span>
10 <span style="color: #008000">//</span><span style="color: #008000">数字类型</span>
"字符串" <span style="color: #008000">//</span><span style="color: #008000">字符串类型</span>
<span style="color: #0000ff">true</span> <span style="color: #008000">//</span><span style="color: #008000">布尔值类型</span>
<span style="color: #0000ff">null</span> <span style="color: #008000">//</span><span style="color: #008000">空</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>对象<strong><strong>JSON表示</strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">对象</span><span style="color: #008000">
//</span><span style="color: #008000">JavaScript对象字面量表示法：</span>
<span style="color: #0000ff">var</span> box =<span style="color: #000000"> {
    name: </span>'Lee'<span style="color: #000000">,
    age: </span>100<span style="color: #000000">
};

</span><span style="color: #008000">//</span><span style="color: #008000">而JSON中的对象表示法需要加上双引号，并且不存在赋值运算和分号：</span>
'{"name":"Lee","age":100}' <span style="color: #008000">//</span><span style="color: #008000">使用双引号，否则转换会出错</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>数组<strong><strong><strong>JSON表示</strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000"> 数组</span><span style="color: #008000">
//</span><span style="color: #008000"> JavaScript数组字面量表示法：</span>
<span style="color: #0000ff">var</span> box = [100, 'Lee', <span style="color: #0000ff">true</span><span style="color: #000000">];

</span><span style="color: #008000">//</span><span style="color: #008000"> 而JSON中的数组表示法同样没有变量赋值和分号：</span>
'[100, "Lee", true]'</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>一般比较常用的一种复杂形式是数组结合对象的形式<strong><strong><strong><strong>JSON表示</strong></strong></strong></strong>：</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">数组结合对象的形式</span>
<span style="color: #000000">[
    {
        </span>"title" : "a"<span style="color: #000000">,
        </span>"num" : 1<span style="color: #000000">
    },
    {
        </span>"title" : "b"<span style="color: #000000">,
        </span>"num" : 2<span style="color: #000000">
    },
    {
        </span>"title" : "c"<span style="color: #000000">,
        </span>"num" : 3<span style="color: #000000">
    }
]</span></pre>
</div>
<p align="left"><span style="color: #ff00ff"><strong>PS：一般情况下，我们可以把JSON结构数据保存到一个文本文件里，然后通过XMLHttpRequest对象去加载它，得到这串结构数据字符串(XMLHttpRequest对象将在Aajx章节中详细探讨)。所以，我们可以模拟这种过程。</strong></span></p>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>模拟加载JSON文本文件的数据，并且赋值给变量。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> box = '[{"name" : "a","age" : 1},{"name" : "b","age" : 2}]';    </pre>
</div>
<p align="left"><strong>PS；上面这短代码模拟了var box = load('demo.json');赋值过程。因为通过load加载的文本文件，不管内容是什么，都必须是字符串。所以两边要加上双引号。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>其实JSON就是比普通数组多了两边的双引号，普通数组如下：</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> box = [{name : 'a', age : 1},{name : 'b', age : 2}];    </pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>二．解析和序列化</strong></span></p>
<p align="left"><strong>如果是载入的JSON文件，我们需要对其进行使用，那么就必须对JSON字符串解析成原生的JavaScript值。当然，如果是原生的JavaScript对象或数组，也可以转换成JSON字符串。</strong></p>
<p align="left"><strong>对于讲JSON字符串解析为JavaScript原生值，早期采用的是eval()函数。但这种方法既不安全，可能会执行一些恶意代码。</strong></p>
<p><span style="color: #ff0000"><strong>eval()函数，JSON字符串解析为JavaScript原生值，参数是要解析的字符串</strong></span><br><strong>使用方式：</strong><br><strong>eval(要解析的字符串)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">模拟加载JSON字符串</span>
<span style="color: #0000ff">var</span> box = '[{"name" : "a","age" : 1},{"name" : "b","age" : 2}]'<span style="color: #000000">;
alert(box);                                </span><span style="color: #008000">//</span><span style="color: #008000">JSON字符串</span>
<span style="color: #0000ff">var</span> json = eval(box);                    <span style="color: #008000">//</span><span style="color: #008000">使用eval()函数解析</span>
alert(json);                            <span style="color: #008000">//</span><span style="color: #008000">得到JavaScript原生值</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>JSON对象</strong></span></p>
<p align="left"><strong>ECMAScript5对解析JSON的行为进行规范，定义了全局对象JSON。支持这个对象的浏览器有IE8+、Firefox3.5+、Safari4+、Chrome和Opera10.5+。不支持的浏览器也可以通过一个开源库json.js来模拟执行。JSON对象提供了两个方法，一个是将原生JavaScript值转换为JSON字符串：stringify()；另一个是将JSON字符串转换为JavaScript原生值：parse()。</strong></p>
<p align="left"><span style="color: #ff0000"><strong>如果浏览器版本太低不支持<strong>JSON对象，<strong>通过一个开源库json2.js来模拟执行，如果支持<strong><strong>JSON对象就用<strong><strong>JSON对象</strong></strong></strong></strong></strong></strong></strong></span></p>
<p align="left"><span style="color: #ff00ff"><strong><strong><strong>json2.js<strong>开源库</strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">/*</span><span style="color: #008000">
    json2.js
    2012-10-08

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&amp;nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n &lt; 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &amp;&amp;
                        value.slice(0, 5) === 'Date(' &amp;&amp;
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
</span><span style="color: #008000">*/</span>

<span style="color: #008000">/*</span><span style="color: #008000">jslint evil: true, regexp: true </span><span style="color: #008000">*/</span>

<span style="color: #008000">/*</span><span style="color: #008000">members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
</span><span style="color: #008000">*/</span>


<span style="color: #008000">//</span><span style="color: #008000"> Create a JSON object only if one does not already exist. We create the</span><span style="color: #008000">
//</span><span style="color: #008000"> methods in a closure to avoid creating global variables.</span>

<span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> JSON !== 'object'<span style="color: #000000">) {
    JSON </span>=<span style="color: #000000"> {};
}

(</span><span style="color: #0000ff">function</span><span style="color: #000000"> () {
    </span>'use strict'<span style="color: #000000">;

    </span><span style="color: #0000ff">function</span><span style="color: #000000"> f(n) {
        </span><span style="color: #008000">//</span><span style="color: #008000"> Format integers to have at least two digits.</span>
        <span style="color: #0000ff">return</span> n &lt; 10 ? '0' +<span style="color: #000000"> n : n;
    }

    </span><span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> Date.prototype.toJSON !== 'function'<span style="color: #000000">) {

        Date.prototype.toJSON </span>= <span style="color: #0000ff">function</span><span style="color: #000000"> (key) {

            </span><span style="color: #0000ff">return</span> isFinite(<span style="color: #0000ff">this</span><span style="color: #000000">.valueOf())
                </span>? <span style="color: #0000ff">this</span>.getUTCFullYear()     + '-' +<span style="color: #000000">
                    f(</span><span style="color: #0000ff">this</span>.getUTCMonth() + 1) + '-' +<span style="color: #000000">
                    f(</span><span style="color: #0000ff">this</span>.getUTCDate())      + 'T' +<span style="color: #000000">
                    f(</span><span style="color: #0000ff">this</span>.getUTCHours())     + ':' +<span style="color: #000000">
                    f(</span><span style="color: #0000ff">this</span>.getUTCMinutes())   + ':' +<span style="color: #000000">
                    f(</span><span style="color: #0000ff">this</span>.getUTCSeconds())   + 'Z'<span style="color: #000000">
                : </span><span style="color: #0000ff">null</span><span style="color: #000000">;
        };

        String.prototype.toJSON      </span>=<span style="color: #000000">
            Number.prototype.toJSON  </span>=<span style="color: #000000">
            Boolean.prototype.toJSON </span>= <span style="color: #0000ff">function</span><span style="color: #000000"> (key) {
                </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span><span style="color: #000000">.valueOf();
            };
    }

    </span><span style="color: #0000ff">var</span> cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/<span style="color: #000000">g,
        escapable </span>= /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/<span style="color: #000000">g,
        gap,
        indent,
        meta </span>= {    <span style="color: #008000">//</span><span style="color: #008000"> table of character substitutions</span>
            '\b': '\\b'<span style="color: #000000">,
            </span>'\t': '\\t'<span style="color: #000000">,
            </span>'\n': '\\n'<span style="color: #000000">,
            </span>'\f': '\\f'<span style="color: #000000">,
            </span>'\r': '\\r'<span style="color: #000000">,
            </span>'"' : '\\"'<span style="color: #000000">,
            </span>'\\': '\\\\'<span style="color: #000000">
        },
        rep;


    </span><span style="color: #0000ff">function</span><span style="color: #000000"> quote(string) {

</span><span style="color: #008000">//</span><span style="color: #008000"> If the string contains no control characters, no quote characters, and no</span><span style="color: #008000">
//</span><span style="color: #008000"> backslash characters, then we can safely slap some quotes around it.</span><span style="color: #008000">
//</span><span style="color: #008000"> Otherwise we must also replace the offending characters with safe escape</span><span style="color: #008000">
//</span><span style="color: #008000"> sequences.</span>
<span style="color: #000000">
        escapable.lastIndex </span>= 0<span style="color: #000000">;
        </span><span style="color: #0000ff">return</span> escapable.test(string) ? '"' + string.replace(escapable, <span style="color: #0000ff">function</span><span style="color: #000000"> (a) {
            </span><span style="color: #0000ff">var</span> c =<span style="color: #000000"> meta[a];
            </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">typeof</span> c === 'string'
                ?<span style="color: #000000"> c
                : </span>'\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4<span style="color: #000000">);
        }) </span>+ '"' : '"' + string + '"'<span style="color: #000000">;
    }


    </span><span style="color: #0000ff">function</span><span style="color: #000000"> str(key, holder) {

</span><span style="color: #008000">//</span><span style="color: #008000"> Produce a string from holder[key].</span>

        <span style="color: #0000ff">var</span> i,          <span style="color: #008000">//</span><span style="color: #008000"> The loop counter.</span>
            k,          <span style="color: #008000">//</span><span style="color: #008000"> The member key.</span>
            v,          <span style="color: #008000">//</span><span style="color: #008000"> The member value.</span>
<span style="color: #000000">            length,
            mind </span>=<span style="color: #000000"> gap,
            partial,
            value </span>=<span style="color: #000000"> holder[key];

</span><span style="color: #008000">//</span><span style="color: #008000"> If the value has a toJSON method, call it to obtain a replacement value.</span>

        <span style="color: #0000ff">if</span> (value &amp;&amp; <span style="color: #0000ff">typeof</span> value === 'object' &amp;&amp;
                <span style="color: #0000ff">typeof</span> value.toJSON === 'function'<span style="color: #000000">) {
            value </span>=<span style="color: #000000"> value.toJSON(key);
        }

</span><span style="color: #008000">//</span><span style="color: #008000"> If we were called with a replacer function, then call the replacer to</span><span style="color: #008000">
//</span><span style="color: #008000"> obtain a replacement value.</span>

        <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> rep === 'function'<span style="color: #000000">) {
            value </span>=<span style="color: #000000"> rep.call(holder, key, value);
        }

</span><span style="color: #008000">//</span><span style="color: #008000"> What happens next depends on the value's type.</span>

        <span style="color: #0000ff">switch</span> (<span style="color: #0000ff">typeof</span><span style="color: #000000"> value) {
        </span><span style="color: #0000ff">case</span> 'string'<span style="color: #000000">:
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> quote(value);

        </span><span style="color: #0000ff">case</span> 'number'<span style="color: #000000">:

</span><span style="color: #008000">//</span><span style="color: #008000"> JSON numbers must be finite. Encode non-finite numbers as null.</span>

            <span style="color: #0000ff">return</span> isFinite(value) ? String(value) : 'null'<span style="color: #000000">;

        </span><span style="color: #0000ff">case</span> 'boolean'<span style="color: #000000">:
        </span><span style="color: #0000ff">case</span> 'null'<span style="color: #000000">:

</span><span style="color: #008000">//</span><span style="color: #008000"> If the value is a boolean or null, convert it to a string. Note:</span><span style="color: #008000">
//</span><span style="color: #008000"> typeof null does not produce 'null'. The case is included here in</span><span style="color: #008000">
//</span><span style="color: #008000"> the remote chance that this gets fixed someday.</span>

            <span style="color: #0000ff">return</span><span style="color: #000000"> String(value);

</span><span style="color: #008000">//</span><span style="color: #008000"> If the type is 'object', we might be dealing with an object or an array or</span><span style="color: #008000">
//</span><span style="color: #008000"> null.</span>

        <span style="color: #0000ff">case</span> 'object'<span style="color: #000000">:

</span><span style="color: #008000">//</span><span style="color: #008000"> Due to a specification blunder in ECMAScript, typeof null is 'object',</span><span style="color: #008000">
//</span><span style="color: #008000"> so watch out for that case.</span>

            <span style="color: #0000ff">if</span> (!<span style="color: #000000">value) {
                </span><span style="color: #0000ff">return</span> 'null'<span style="color: #000000">;
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> Make an array to hold the partial results of stringifying this object value.</span>
<span style="color: #000000">
            gap </span>+=<span style="color: #000000"> indent;
            partial </span>=<span style="color: #000000"> [];

</span><span style="color: #008000">//</span><span style="color: #008000"> Is the value an array?</span>

            <span style="color: #0000ff">if</span> (Object.prototype.toString.apply(value) === '[object Array]'<span style="color: #000000">) {

</span><span style="color: #008000">//</span><span style="color: #008000"> The value is an array. Stringify every element. Use null as a placeholder</span><span style="color: #008000">
//</span><span style="color: #008000"> for non-JSON values.</span>
<span style="color: #000000">
                length </span>=<span style="color: #000000"> value.length;
                </span><span style="color: #0000ff">for</span> (i = 0; i &lt; length; i += 1<span style="color: #000000">) {
                    partial[i] </span>= str(i, value) || 'null'<span style="color: #000000">;
                }

</span><span style="color: #008000">//</span><span style="color: #008000"> Join all of the elements together, separated with commas, and wrap them in</span><span style="color: #008000">
//</span><span style="color: #008000"> brackets.</span>
<span style="color: #000000">
                v </span>= partial.length === 0
                    ? '[]'<span style="color: #000000">
                    : gap
                    </span>? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'<span style="color: #000000">
                    : </span>'[' + partial.join(',') + ']'<span style="color: #000000">;
                gap </span>=<span style="color: #000000"> mind;
                </span><span style="color: #0000ff">return</span><span style="color: #000000"> v;
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> If the replacer is an array, use it to select the members to be stringified.</span>

            <span style="color: #0000ff">if</span> (rep &amp;&amp; <span style="color: #0000ff">typeof</span> rep === 'object'<span style="color: #000000">) {
                length </span>=<span style="color: #000000"> rep.length;
                </span><span style="color: #0000ff">for</span> (i = 0; i &lt; length; i += 1<span style="color: #000000">) {
                    </span><span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> rep[i] === 'string'<span style="color: #000000">) {
                        k </span>=<span style="color: #000000"> rep[i];
                        v </span>=<span style="color: #000000"> str(k, value);
                        </span><span style="color: #0000ff">if</span><span style="color: #000000"> (v) {
                            partial.push(quote(k) </span>+ (gap ? ': ' : ':') +<span style="color: #000000"> v);
                        }
                    }
                }
            } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {

</span><span style="color: #008000">//</span><span style="color: #008000"> Otherwise, iterate through all of the keys in the object.</span>

                <span style="color: #0000ff">for</span> (k <span style="color: #0000ff">in</span><span style="color: #000000"> value) {
                    </span><span style="color: #0000ff">if</span><span style="color: #000000"> (Object.prototype.hasOwnProperty.call(value, k)) {
                        v </span>=<span style="color: #000000"> str(k, value);
                        </span><span style="color: #0000ff">if</span><span style="color: #000000"> (v) {
                            partial.push(quote(k) </span>+ (gap ? ': ' : ':') +<span style="color: #000000"> v);
                        }
                    }
                }
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> Join all of the member texts together, separated with commas,</span><span style="color: #008000">
//</span><span style="color: #008000"> and wrap them in braces.</span>
<span style="color: #000000">
            v </span>= partial.length === 0
                ? '{}'<span style="color: #000000">
                : gap
                </span>? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'<span style="color: #000000">
                : </span>'{' + partial.join(',') + '}'<span style="color: #000000">;
            gap </span>=<span style="color: #000000"> mind;
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> v;
        }
    }

</span><span style="color: #008000">//</span><span style="color: #008000"> If the JSON object does not yet have a stringify method, give it one.</span>

    <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> JSON.stringify !== 'function'<span style="color: #000000">) {
        JSON.stringify </span>= <span style="color: #0000ff">function</span><span style="color: #000000"> (value, replacer, space) {

</span><span style="color: #008000">//</span><span style="color: #008000"> The stringify method takes a value and an optional replacer, and an optional</span><span style="color: #008000">
//</span><span style="color: #008000"> space parameter, and returns a JSON text. The replacer can be a function</span><span style="color: #008000">
//</span><span style="color: #008000"> that can replace values, or an array of strings that will select the keys.</span><span style="color: #008000">
//</span><span style="color: #008000"> A default replacer method can be provided. Use of the space parameter can</span><span style="color: #008000">
//</span><span style="color: #008000"> produce text that is more easily readable.</span>

            <span style="color: #0000ff">var</span><span style="color: #000000"> i;
            gap </span>= ''<span style="color: #000000">;
            indent </span>= ''<span style="color: #000000">;

</span><span style="color: #008000">//</span><span style="color: #008000"> If the space parameter is a number, make an indent string containing that</span><span style="color: #008000">
//</span><span style="color: #008000"> many spaces.</span>

            <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> space === 'number'<span style="color: #000000">) {
                </span><span style="color: #0000ff">for</span> (i = 0; i &lt; space; i += 1<span style="color: #000000">) {
                    indent </span>+= ' '<span style="color: #000000">;
                }

</span><span style="color: #008000">//</span><span style="color: #008000"> If the space parameter is a string, it will be used as the indent string.</span>
<span style="color: #000000">
            } </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> space === 'string'<span style="color: #000000">) {
                indent </span>=<span style="color: #000000"> space;
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> If there is a replacer, it must be a function or an array.</span><span style="color: #008000">
//</span><span style="color: #008000"> Otherwise, throw an error.</span>
<span style="color: #000000">
            rep </span>=<span style="color: #000000"> replacer;
            </span><span style="color: #0000ff">if</span> (replacer &amp;&amp; <span style="color: #0000ff">typeof</span> replacer !== 'function' &amp;&amp;<span style="color: #000000">
                    (</span><span style="color: #0000ff">typeof</span> replacer !== 'object' ||
                    <span style="color: #0000ff">typeof</span> replacer.length !== 'number'<span style="color: #000000">)) {
                </span><span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('JSON.stringify'<span style="color: #000000">);
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> Make a fake root object containing our value under the key of ''.</span><span style="color: #008000">
//</span><span style="color: #008000"> Return the result of stringifying the value.</span>

            <span style="color: #0000ff">return</span> str('', {''<span style="color: #000000">: value});
        };
    }


</span><span style="color: #008000">//</span><span style="color: #008000"> If the JSON object does not yet have a parse method, give it one.</span>

    <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> JSON.parse !== 'function'<span style="color: #000000">) {
        JSON.parse </span>= <span style="color: #0000ff">function</span><span style="color: #000000"> (text, reviver) {

</span><span style="color: #008000">//</span><span style="color: #008000"> The parse method takes a text and an optional reviver function, and returns</span><span style="color: #008000">
//</span><span style="color: #008000"> a JavaScript value if the text is a valid JSON text.</span>

            <span style="color: #0000ff">var</span><span style="color: #000000"> j;

            </span><span style="color: #0000ff">function</span><span style="color: #000000"> walk(holder, key) {

</span><span style="color: #008000">//</span><span style="color: #008000"> The walk method is used to recursively walk the resulting structure so</span><span style="color: #008000">
//</span><span style="color: #008000"> that modifications can be made.</span>

                <span style="color: #0000ff">var</span> k, v, value =<span style="color: #000000"> holder[key];
                </span><span style="color: #0000ff">if</span> (value &amp;&amp; <span style="color: #0000ff">typeof</span> value === 'object'<span style="color: #000000">) {
                    </span><span style="color: #0000ff">for</span> (k <span style="color: #0000ff">in</span><span style="color: #000000"> value) {
                        </span><span style="color: #0000ff">if</span><span style="color: #000000"> (Object.prototype.hasOwnProperty.call(value, k)) {
                            v </span>=<span style="color: #000000"> walk(value, k);
                            </span><span style="color: #0000ff">if</span> (v !==<span style="color: #000000"> undefined) {
                                value[k] </span>=<span style="color: #000000"> v;
                            } </span><span style="color: #0000ff">else</span><span style="color: #000000"> {
                                </span><span style="color: #0000ff">delete</span><span style="color: #000000"> value[k];
                            }
                        }
                    }
                }
                </span><span style="color: #0000ff">return</span><span style="color: #000000"> reviver.call(holder, key, value);
            }


</span><span style="color: #008000">//</span><span style="color: #008000"> Parsing happens in four stages. In the first stage, we replace certain</span><span style="color: #008000">
//</span><span style="color: #008000"> Unicode characters with escape sequences. JavaScript handles many characters</span><span style="color: #008000">
//</span><span style="color: #008000"> incorrectly, either silently deleting them, or treating them as line endings.</span>
<span style="color: #000000">
            text </span>=<span style="color: #000000"> String(text);
            cx.lastIndex </span>= 0<span style="color: #000000">;
            </span><span style="color: #0000ff">if</span><span style="color: #000000"> (cx.test(text)) {
                text </span>= text.replace(cx, <span style="color: #0000ff">function</span><span style="color: #000000"> (a) {
                    </span><span style="color: #0000ff">return</span> '\\u' +<span style="color: #000000">
                        (</span>'0000' + a.charCodeAt(0).toString(16)).slice(-4<span style="color: #000000">);
                });
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> In the second stage, we run the text against regular expressions that look</span><span style="color: #008000">
//</span><span style="color: #008000"> for non-JSON patterns. We are especially concerned with '()' and 'new'</span><span style="color: #008000">
//</span><span style="color: #008000"> because they can cause invocation, and '=' because it can cause mutation.</span><span style="color: #008000">
//</span><span style="color: #008000"> But just to be safe, we want to reject all unexpected forms.</span>

<span style="color: #008000">//</span><span style="color: #008000"> We split the second stage into 4 regexp operations in order to work around</span><span style="color: #008000">
//</span><span style="color: #008000"> crippling inefficiencies in IE's and Safari's regexp engines. First we</span><span style="color: #008000">
//</span><span style="color: #008000"> replace the JSON backslash pairs with '@' (a non-JSON character). Second, we</span><span style="color: #008000">
//</span><span style="color: #008000"> replace all simple value tokens with ']' characters. Third, we delete all</span><span style="color: #008000">
//</span><span style="color: #008000"> open brackets that follow a colon or comma or that begin the text. Finally,</span><span style="color: #008000">
//</span><span style="color: #008000"> we look to see that the remaining characters are only whitespace or ']' or</span><span style="color: #008000">
//</span><span style="color: #008000"> ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.</span>

            <span style="color: #0000ff">if</span> (/^[\],:{}\s]*$/<span style="color: #000000">
                    .test(text.replace(</span>/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@'<span style="color: #000000">)
                        .replace(</span>/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']'<span style="color: #000000">)
                        .replace(</span>/(?:^|:|,)(?:\s*\[)+/g, ''<span style="color: #000000">))) {

</span><span style="color: #008000">//</span><span style="color: #008000"> In the third stage we use the eval function to compile the text into a</span><span style="color: #008000">
//</span><span style="color: #008000"> JavaScript structure. The '{' operator is subject to a syntactic ambiguity</span><span style="color: #008000">
//</span><span style="color: #008000"> in JavaScript: it can begin a block or an object literal. We wrap the text</span><span style="color: #008000">
//</span><span style="color: #008000"> in parens to eliminate the ambiguity.</span>
<span style="color: #000000">
                j </span>= eval('(' + text + ')'<span style="color: #000000">);

</span><span style="color: #008000">//</span><span style="color: #008000"> In the optional fourth stage, we recursively walk the new structure, passing</span><span style="color: #008000">
//</span><span style="color: #008000"> each name/value pair to a reviver function for possible transformation.</span>

                <span style="color: #0000ff">return</span> <span style="color: #0000ff">typeof</span> reviver === 'function'
                    ? walk({'': j}, ''<span style="color: #000000">)
                    : j;
            }

</span><span style="color: #008000">//</span><span style="color: #008000"> If the text is not JSON parseable, then a SyntaxError is thrown.</span>

            <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> SyntaxError('JSON.parse'<span style="color: #000000">);
        };
    }
}());</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>无论是JSON对象，还是开源库json2.js来模拟执行，都有两个方法</strong></span></p>
<p align="left"><span style="color: #ff00ff"><strong>JSON对象提供了两个方法，一个是将原生JavaScript值转换为JSON字符串：stringify()；另一个是将JSON字符串转换为JavaScript原生值：parse()。</strong></span></p>
<p><span style="color: #ff0000"><strong>parse()方法，将JSON字符串转换为JavaScript原生数据，参数是JSON字符串，第二个可选参数可以是函数</strong></span><br><strong>使用方式</strong><br><strong>JSON对象.parse(JSON字符串)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box = '[{"name" : "a","age" : 1},{"name" : "b","age" : 2}]';    <span style="color: #008000">//</span><span style="color: #008000">JSON字符串,特别注意，键要用双引号</span>
<span style="color: #000000">alert(box);
</span><span style="color: #0000ff">var</span> json = JSON.parse(box);      <span style="color: #008000">//</span><span style="color: #008000">parse()方法，将JSON字符串转换为JavaScript原生数据，参数是JSON字符串</span>
alert(json);  <span style="color: #008000">//</span><span style="color: #008000">打印转换后的JavaScript原生数据</span></pre>
</div>
<p><span style="color: #ff0000"><strong><strong>解析JSON字符串方法parse()也可以接受第二个参数，这样可以在还原出JavaScript值的时候替换成自己想要的值。</strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box = '[{"name" : "a","age" : 1},{"name" : "b","age" : 2}]';  <span style="color: #008000">//</span><span style="color: #008000">json字符串</span>
<span style="color: #0000ff">var</span> json = JSON.parse(box, <span style="color: #0000ff">function</span> (key, value) {  <span style="color: #008000">//</span><span style="color: #008000">第二个参数为匿名函数，接受对象的键和值</span>
    <span style="color: #0000ff">if</span> (key == 'name') {  <span style="color: #008000">//</span><span style="color: #008000">判断对象的键等于name</span>
        <span style="color: #0000ff">return</span> 'Mr. ' + value;  <span style="color: #008000">//</span><span style="color: #008000">改变值</span>
    } <span style="color: #0000ff">else</span><span style="color: #000000"> {
        </span><span style="color: #0000ff">return</span> value;  <span style="color: #008000">//</span><span style="color: #008000">返回值</span>
<span style="color: #000000">    }
});
alert(json[</span>0].name); <span style="color: #008000">//</span><span style="color: #008000">打印第一个对象的name值</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>stringify()方法，将JavaScript原生数据转换为JSON字符串，参数是JavaScript原生数据,[可选参数，第一个参数可以是一个数组，也可以是一个函数，用于过滤结果。第二个参数则表示是否在JSON字符串中保留缩进。]</strong></span><br><strong>使用方式</strong><br><strong>JSON对象.stringify(JavaScript原生数据)</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box = [{name : 'a', age : 1},{name : 'b', age : 2}];    <span style="color: #008000">//</span><span style="color: #008000">JavaScript原生数据</span>
<span style="color: #000000">alert(box);
</span><span style="color: #0000ff">var</span> json = JSON.stringify(box);                        <span style="color: #008000">//</span><span style="color: #008000">转换成JSON字符串</span>
alert(json);                                        <span style="color: #008000">//</span><span style="color: #008000">自动双引号</span></pre>
</div>
<p align="left"><span style="color: #ff0000"><strong>在序列化JSON的过程中，stringify()方法还提供了两个可选参数。第一个参数可以是一个数组，也可以是一个函数，用于过滤结果。第二个参数则表示是否在JSON字符串中保留缩进。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box = [{name : 'a', age : 1, height : 177},{name : 'b', age : 2, height : 188}];  <span style="color: #008000">//</span><span style="color: #008000">JavaScript原生数据</span><span style="color: #008000">
//</span><span style="color: #008000">stringify()方法还提供了两个可选参数。第一个参数可以是一个数组，也可以是一个函数，用于过滤结果。第二个参数则表示是否在JSON字符串中保留缩进。</span>
<span style="color: #0000ff">var</span> json = JSON.stringify(box, ['name', 'age'], 4);  <span style="color: #008000">//</span><span style="color: #008000">只解析name和age，过滤掉height，保留缩进4</span>
alert(json); <span style="color: #008000">//</span><span style="color: #008000">打印JSON字符串</span></pre>
</div>
<p><span style="color: #ff0000"><strong>如果不需要保留缩进，则不填即可；如果不需要过滤结果，但又要保留缩进，则将过滤结果的参数设置为null。如果采用函数，可以进行复杂的过滤。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box = [{name: 'a', age: 1, height: 177}, {name: 'b', age: 2, height: 188}];  <span style="color: #008000">//</span><span style="color: #008000">JavaScript原生数据</span><span style="color: #008000">
//</span><span style="color: #008000">stringify()方法还提供了两个可选参数。第一个参数可以是一个数组，也可以是一个函数，用于过滤结果。第二个参数则表示是否在JSON字符串中保留缩进。</span>
<span style="color: #0000ff">var</span> json = JSON.stringify(box, <span style="color: #0000ff">function</span> (key, value) {  <span style="color: #008000">//</span><span style="color: #008000">设置一个匿名函数，分别接受对象的键和值</span>
    <span style="color: #0000ff">switch</span> (key) {  <span style="color: #008000">//</span><span style="color: #008000">多重判断key键</span>
        <span style="color: #0000ff">case</span> 'name' :  <span style="color: #008000">//</span><span style="color: #008000">如果键是name</span>
            <span style="color: #0000ff">return</span> 'Mr. ' + value;  <span style="color: #008000">//</span><span style="color: #008000">将name值改变成</span>
        <span style="color: #0000ff">case</span> 'age' :   <span style="color: #008000">//</span><span style="color: #008000">如果键是age</span>
            <span style="color: #0000ff">return</span> value + '岁'<span style="color: #000000">;
        </span><span style="color: #0000ff">default</span><span style="color: #000000"> :
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> value;
    }
}, </span>4<span style="color: #000000">);
alert(json);  </span><span style="color: #008000">//</span><span style="color: #008000">返回改变后的json字符串</span></pre>
</div>
<p align="left"><span style="color: #ff00ff"><strong>PS：保留缩进除了是普通的数字，也可以是字符。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>还有一种方法可以自定义过滤一些数据，使用toJSON()方法，可以将某一组对象里指定返回某个值。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">注意：引入了开源库json2，如果浏览器版本太低不支持JSON对象，通过一个开源库json2.js来模拟执行，如果支持JSON对象就用JSON对象</span>
<span style="color: #0000ff">var</span> box =<span style="color: #000000"> [{
    name: </span>'a', age: 1, height: 177, toJSON: <span style="color: #0000ff">function</span><span style="color: #000000"> () {
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>.name;  <span style="color: #008000">//</span><span style="color: #008000">返回当前对象的name</span>
<span style="color: #000000">    }
}, {
    name: </span>'b', age: 2, height: 188, toJSON: <span style="color: #0000ff">function</span><span style="color: #000000"> () {
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>.name;  <span style="color: #008000">//</span><span style="color: #008000">返回当前对象的name</span>
<span style="color: #000000">    }
}];
</span><span style="color: #0000ff">var</span> json = JSON.stringify(box);  <span style="color: #008000">//</span><span style="color: #008000">最后返回对象里的name值字符串</span>
alert(json);  </pre>
</div>
<p align="left"><strong>PS：由此可见序列化也有执行顺序，首先先执行toJSON()方法；如果应用了第二个过滤参数，则执行这个方法；然后执行序列化过程，比如将键值对组成合法的JSON字符串，比如加上双引号。如果提供了缩进，再执行缩进操作。</strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong>&nbsp;</strong></strong></span></p></div>