
---
layout: post
title: " 第三十节，正则表达式re模块 "
author: "Ans1ble"
header-style: text
tags:
      - Python
---


**正则表达式**

正则表达式本身是一种小型的、高度专业化的编程语言，而在python中，通过内嵌集成re模块，程序员们可以直接调用来实现正则匹配。正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。

![](https://images2015.cnblogs.com/blog/955761/201608/955761-20160805200743450-1819053688.png)

**正则表达式是用来匹配处理字符串的  python 中使用正则表达式需要引入re模块**

如：

**import re #第一步，要引入re模块**

**a = re.findall("匹配规则", "要匹配的字符串") #第二步，调用模块函数**

**以列表形式返回匹配到的字符串**

**如：**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则", "这个字符串是否有匹配规则的字符")   #第二步，调用模块函数
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]



**字符匹配（普通字符，元字符）**

**普通字符：是没有包含特殊意义的字符，大多以数字字母和中文汉字的，以自身匹配**

**也就是查找字符串里是否有包含匹配规则的字符串，必须完全包含才匹配**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则", "这个字符串是否有匹配规则的字符")   #第二步，调用模块函数
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]



**元字符：是包含 **特殊意义的字符，一般都是和普通字符搭配使用的****



****.元字符****

****需要字符串里完全符合，匹配规则，就匹配，（规则里的 ** **.元字符**** ）可以是任何一个字符****

****匹配任意除换行符"\n"外的字符(在DOTALL模式中也能匹配换行符)****

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规.则", "这个字符串是否有匹配规a则的字符")   #需要完全符合匹配规则，（.元字符）可以是任何一个字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]



**^元字符**

**字符串开始位置与匹配规则符合就匹配，否则不匹配**

**匹配字符串开头。在多行模式中匹配每一行的开头**

[code]

    **^元字符如果写到[]字符集里就是反取**
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("^匹配规则", "匹配规则这个字符串是否匹配")   #字符串开始位置与匹配规则符合就匹配，否则不匹配
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]

[code]

    **[^a-z]反取，匹配出除字母外的字符，^元字符如果写到字符集里就是反取  
    **
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("[^a-z]", "匹配s规则这s个字符串是否s匹配f规则则re则则则")   #反取，匹配出除字母外的字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']
[/code]

[/code]

[code]

**$元字符**

****字符串结束位置与匹配规则符合就匹配，否则不匹配****

****匹配字符串末尾，在多行模式中匹配每一行的末尾****

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则$", "这个字符串是否匹配规则")   #字符串结束位置与匹配规则符合就匹配，否则不匹配
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]



***元字符**

****需要字符串里完全符合，匹配规则，就匹配，（规则里的 ** ***元字符**** ）前面的一个字符可以是0个或多个原本字符****

****匹配前一个字符0或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪****

****如果规则里只有一个分组，尽量避免用*否则会有可能匹配出空字符串****

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则*", "这个字符串是否匹配规则则则则则")   #需要字符串里完全符合，匹配规则，就匹配，（规则里的*元字符）前面的一个字符可以是0或多个原本字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则则则则则']
[/code]



**+元字符**

******需要字符串里完全符合，匹配规则，就匹配，（规则里的 ** **+元字符**** ）前面的一个字符可以是1个或多个原本字符******

******匹配前一个字符1次或无限次， ** **贪婪匹配前导字符有多少个就匹配多少个很贪婪**********

[code]

     #!/usr/bin/env python
    # -*- coding:gbk -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配+", "匹配配配配配规则这个字符串是否匹配规则则则则则")   #需要字符串里完全符合，匹配规则，就匹配，（规则里的+元字符）前面的一个字符可以是1个或多个原本字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配配配配配', '匹配']
[/code]



**?元字符，和 ** ** ** **防止贪婪匹配**********

********需要字符串里完全符合，匹配规则，就匹配，（规则里的 ** **?元字符**** ）前面的一个字符可以是0个或1个原本字符********

********匹配一个字符0次或1次********

********还有一个功能是可以防止贪婪匹配，详情见防贪婪匹配********

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则?", "匹配规这个字符串是否匹配规则则则则则")   #需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规', '匹配规则']
[/code]



**{}元字符,范围**

**********需要字符串里完全符合，匹配规则，就匹配，（规则里的   ** **{} 元字符****
）前面的一个字符，是自定义字符数，位数的原本字符**********

**********{m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次**********

{0,}匹配前一个字符0或多次,等同于*元字符  
{+,}匹配前一个字符1次或无限次,等同于+元字符  
{0,1}匹配前一个字符0次或1次,等同于?元字符

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则{3}", "匹配规这个字符串是否匹配规则则则则则")   #{m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则则则']
[/code]



**[]元字符,字符集**

************需要字符串里完全符合，匹配规则，就匹配，（规则里的   ** **[] 元字符**** ）对应位置是 ** ** ** ** **
** ** **[]里的任意一个字符就匹配****************************

****************************字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。  
所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。****************************

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配[a,b,c]规则", "匹配a规则这个字符串是否匹配规则则则则则")   #需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配a规则']
[/code]

[code]

    **[^]非，反取，匹配出除[^]里面的字符，^元字符如果写到字符集里就是反取  
    **
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("[^a-z]", "匹配s规则这s个字符串是否s匹配f规则则re则则则")   #反取，匹配出除字母外的字符
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']
[/code]



**\元字符**

**1.反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符）**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配\.规则", "匹配.规则这个字符串是否匹配规则则则则则")   #反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符）
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配.规则']
[/code]



**2.反斜杠后边跟普通字符实现特殊功能；（即预定义字符）**

**预定义字符是在字符集和组里都是有用的**

\d匹配任何十进制数，它相当于类[0-9]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("\d", "匹配规则这2个字符串3是否匹配规则5则则则7则")   #\d匹配任何十进制数，它相当于类[0-9]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['2', '3', '5', '7']
[/code]

\d+如果需要匹配一位或者多位数的数字时用

[code]

    #!/usr/bin/env python
    # -*- coding:gbk -*-
    import re   #第一步，要引入re模块
    a = re.findall("\d+", "匹配规则这2个字符串134444是否匹配规则5则则则7则")   #\d+如果需要匹配一位或者多位数的数字时用
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['2', '134444', '5', '7']
[/code]

\D匹配任何非数字字符，它相当于类[^0-9]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("\D", "匹配规则这2个字符串3是否匹配规则5则则则7则")   #\D匹配任何非数字字符，它相当于类[^0-9]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']
[/code]

\s匹配任何空白字符，它相当于类[\t\n\r\f\v]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("\s", "匹配规则   这2个字符串3是否匹配规则5则则则7则")   #\s匹配任何空白字符，它相当于类[\t\n\r\f\v]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 [' ', ' ', ' ']
[/code]

\S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("\S", "匹配规则   这2个字符串3是否匹配规则5则则则7则")   #\S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹', '配', '规', '则', '这', '2', '个', '字', '符', '串', '3', '是', '否', '匹', '配', '规', '则', '5', '则', '则', '则', '7', '则']
[/code]

\w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    a = re.findall('\w',"http://www.cnb_logs.com/")  #\w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['h', 't', 't', 'p', 'w', 'w', 'w', 'c', 'n', 'b', '_', 'l', 'o', 'g', 's', 'c', 'o', 'm']
[/code]

\W匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    a = re.findall('\W',"http://www.cnb_logs.com/")  #\W匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 [':', '/', '/', '.', '.', '/']
[/code]

\b匹配一个单词边界，也就是指单词和空格间的位置

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    #也就是分组匹配，()里面的为一个组也可以理解成一个整体
    a = re.findall(r"\babc\b", "a4a4a4a abc 4a4dggdg4g654gb")   #\b匹配一个单词边界，也就是指单词和空格间的位置
    print(a)
    #打印出 ['abc']
[/code]



**3.\2引用序号对应的字组所匹配的字符串。**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    #也就是分组匹配，()里面的为一个组也可以理解成一个整体
    a = re.search(r"(a4)(dg)g\2", "a4a4a4a4a4dggdg4g654gb")   #引用序号对应的字组所匹配的字符串,\2就是引用第2个组(dg)
    b = a.group()
    print(b)
    #打印出 a4dggdg
[/code]



**()元字符，分组**

**也就是分组匹配， **()里面的为一个组也可以理解成一个整体****

****如果()后面跟的是特殊元字符如   (adc)*   那么*控制的前导字符就是()里的整体内容，不再是前导一个字符****

列1

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    #也就是分组匹配，()里面的为一个组也可以理解成一个整体
    a = re.search("(a4)+", "a4a4a4a4a4dg4g654gb")   #匹配一个或多个a4
    b = a.group()
    print(b)
    #打印出 a4a4a4a4a4
[/code]

 列2

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    #也就是分组匹配，()里面的为一个组也可以理解成一个整体
    a = re.search("a(\d+)", "a466666664a4a4a4dg4g654gb")    #匹配 (a) (\d0-9的数字) (+可以是1个到多个0-9的数字)
    b = a.group()
    print(b)
    #打印出 a466666664
[/code]



**|元字符，或**

**|或，或就是前后其中一个符合就匹配**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    a = re.findall(r"你|好", "a4a4a你4aabc4a4dgg好dg4g654g")   #|或，或就是前后其中一个符合就匹配
    print(a)
    #打印出 ['你', '好']
[/code]



**r原生字符**

**将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re   #第一步，要引入re模块
    a = re.findall(r"\b", "a4 a4a你4aabc4 a4dgg好 dg4g654g")   #将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义）
    print(a)
    #打印出 ['', '', '', '', '', '', '', ''] 如果不加r就匹配不到空格
[/code]



## re模块中常用功能函数

正则表达式有两种书写方式，一种是直接在函数里书写规则，

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    import re   #第一步，要引入re模块
    a = re.findall("匹配规则", "这个字符串是否有匹配规则的字符")   #第二步，调用模块函数
    print(a)  #以列表形式返回匹配到的字符串
    #打印出 ['匹配规则']
[/code]

一种是用 **compile()函数将规则编译成对象在用功能函数调用编译对象**

**compile()， **参数（"正则规则"，标示）****

编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）

格式：

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    tt = "Tina is a good girl, she is cool, clever, and so on..."
    rr = re.compile(r'\w*oo\w*')
    a = rr.findall(tt)   #查找所有包含'oo'的单词
    print(a)
    #执行结果如下：
    ['good', 'cool']
[/code]

**re.compile(pattern,flags=0)**

**pattern正则模式：编译时用的表达式字符串**

**flags标示：编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的有**

**默认为标示为flags=0，也就是取全部匹配到的，**

**flags标示，匹配模式**

标志

|

含义  
  
---|---  
  
re.S(DOTALL)

|

使.匹配包括换行在内的所有字符  
  
re.I（IGNORECASE）

|

使匹配对大小写不敏感  
  
re.L（LOCALE）

|

做本地化识别（locale-aware)匹配，法语等  
  
re.M(MULTILINE)

|

多行匹配，影响^和$  
  
re.X(VERBOSE)

|

该标志通过给予更灵活的格式以便将正则表达式写得更易于理解  
  
re.U

|

根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B

[code]

    #!/usr/bin/env python
    # -*- coding:gbk -*-
    import re
    #无分组
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.match("H\w+", origin,re.I)    #re.I使匹配对大小写不敏感
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # hello     匹配到的全部拿出来，加了re.I标示所以字符串里的小写h也匹配的
    # ()        没有分组所以为空
    # {}        没分组部分定义了key的组所以为空
[/code]  
  


**match()函数（以后常用）**

**match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None**  
 **match(pattern, string, flags=0)**  
 **# pattern： 正则模型**  
 **# string ： 要匹配的字符串**  
 **# falgs ： 匹配模式**

_****注意：match()函数 与   **search()函数基本是一样的功能，不一样的就是 _ **
**match()匹配字符串开始位置的一个符合规则的字符串， _ ** ** **search()是在字符串全局匹配第一个 _ ** ** ** _ **
**合规则的字符串****_******_******_****_******_

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    #无分组
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.match("h\w+", origin)    #match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # hello     匹配到的全部拿出来
    # ()        没有分组所以为空
    # {}        没分组部分定义了key的组所以为空
    
    
    # 有分组
    # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
    r = re.match("h(\w+)", origin)   #match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # hello         匹配到的全部拿出来
    # ('ello',)     有分组，在匹配到的字符串中拿出分组的部分
    # {}            没分组部分定义了key的组所以为空
    
    
    # 有两个分组定义了key
    # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
    r = re.match("(?P<n1>h)(?P<n2>\w+)", origin)   #?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # hello                         匹配到的全部拿出来
    # ('h', 'ello')                 有分组，在匹配到的字符串中拿出分组的部分
    # {'n1': 'h', 'n2': 'ello'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来
[/code]

?P<n1>  #?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容（ **只对正则函数返回对象的有用** ）

**取出匹配对象方法**

**只对正则函数返回对象的有用**

group() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2  
groups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果  
groupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果





**search()函数**  
 **search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None**  
 **search(pattern, string, flags=0)**  
 **# pattern： 正则模型**  
 **# string ： 要匹配的字符串**  
 **# falgs ： 匹配模式**

**_****注意：match()函数 与   **search()函数基本是一样的功能，不一样的就是 _ **
**match()匹配字符串开始位置的一个符合规则的字符串， _ ** ** **search()是在字符串全局匹配第一个 _ ** ** ** _ **
**合规则的字符串****_******_******_****_******_**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    #无分组
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.search("a\w+", origin)    #search浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # alex     匹配到的全部拿出来
    # ()        没有分组所以为空
    # {}        没分组部分定义了key的组所以为空
    
    
    # 有分组
    # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
    r = re.search("a(\w+).*(\d)", origin)
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # alex bcd alex lge alex acd 19       匹配到的全部拿出来
    # ('lex', '9')     有分组，在匹配到的字符串中拿出分组的部分
    # {}            没分组部分定义了key的组所以为空
    
    
    # 有两个分组定义了key
    # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
    r = re.search("a(?P<n1>\w+).*(?P<n2>\d)", origin)   #?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
    print(r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
    print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
    print(r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
    #输出结果
    # alex bcd alex lge alex acd 19                         匹配到的全部拿出来
    # ('lex', '9')                 有分组，在匹配到的字符串中拿出分组的部分
    # {'n1': 'lex', 'n2': '9'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来
[/code]



**findall()函数（以后常用）**

******findall** (pattern, string, flags=0)**  
 **# pattern： 正则模型**  
 **# string ： 要匹配的字符串**  
 **# falgs ： 匹配模式****

**浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中， **未匹配成功返回空列表****

**注意：一旦匹配成，再次匹配，是从前一次匹配成功 **的** ，后面一位开始的，也可以理解为匹配成功的字符串，不在参与下次匹配**

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    #无分组
    r = re.findall("\d+\w\d+", "a2b3c4d5")    #浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
    print(r)
    #输出结果
    #['2b3', '4d5']
    #注意：匹配成功的字符串，不在参与下次匹配,所以3c4也符合规则但是没匹配到
[/code]

  **注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    #无分组
    r = re.findall("", "a2b3c4d5")    #浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
    print(r)
    #输出结果
    #['', '', '', '', '', '', '', '', '']
    #注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表 ** **
[/code]

[/code]

[code]

**注意：正则匹配到空字符的情况
，如果规则里只有一个组，而组后面是*就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用*否则会有可能匹配出空字符串**

**注意：正则只拿组里最后一位 ，如果规则里只有一个组，匹配到的字符串里在拿组内容是，拿的是匹配到的内容最后一位**

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.findall("(a)*", origin)   
    print(r)
    #输出结果 ['', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', 'a', '', '', '', '', '', '']
[/code]



[code]

    **  
    无分组：匹配所有合规则的字符串，匹配到的字符串放到一个列表中  
    **
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    #无分组
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.findall("a\w+", origin)    #浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
    print(r)
    #输出结果
    #['alex', 'alex', 'alex', 'acd']
    #匹配所有合规则的字符串，匹配到的字符串放到一个列表中
[/code]

**有分组：只将匹配到的字符串里，组的部分放到列表里返回，相当于groups()方法**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.findall("a(\w+)", origin)    #有分组：只将匹配到的字符串里，组的部分放到列表里返回
    print(r)
    #输出结果
    #['lex', 'lex', 'lex', 'cd']
[/code]

**  多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返**

**相当于在group()结果里再将组的部分，分别，拿出来放入一个元组，最后将所有元组放入一个列表返回**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.findall("(a)(\w+)", origin)    #多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返回
    print(r)
    #输出结果
    #[('a', 'lex'), ('a', 'lex'), ('a', 'lex'), ('a', 'cd')]
[/code]

**
分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回**

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.findall("(a)(\w+(e))", origin)    #分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回
    print(r)
    #输出结果
    #[('a', 'le', 'e'), ('a', 'le', 'e'), ('a', 'le', 'e')]
[/code]

[code]

    **?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()**
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    b = re.findall("a(?:\w+)",origin) #?:在有分组的情况下，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()
    print(b)
    #输出
    # ['alex', 'alex', 'alex', 'acd']
[/code]

[/code]

[code]

**finditer()函数**

****finditer** (pattern, string, flags=0)  
# pattern： 正则模型  
# string ： 要匹配的字符串  
# falgs ： 匹配模式**

****（需要for循环）浏览全部字符串，匹配所有合规则的字符串，返回一个需要for循环的对象，匹配成功for循环后返回对应个数的正则对象，
**未匹配成功返回空******

******finditer()** 和findall()函数基本一样的， **finditer()不一样的是需要for循环后 ** **
**返回匹配到的对应个数对象************

************因为返回的是正则对象，所以需要用到对象方法************

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.finditer("a\w*(?P<n1>\w)", origin)    #浏览全部字符串，匹配所有合规则的字符串，返回一个需要for循环的对象，匹配成功for循环后返回对应个数的正则对象，未匹配成功返回空
    for i in r:
        print(i.group())
        print(i.groupdict())
    #输出结果
    # alex
    # {'n1': 'x'}
    # alex
    # {'n1': 'x'}
    # alex
    # {'n1': 'x'}
    # acd
    # {'n1': 'd'}
    #因为返回的是正则对象，所以需要用到对象方法
[/code]



**split()函数**

**根据正则匹配分割字符串，返回分割后的一个列表**

**`split(pattern, string, maxsplit``=``0``, flags``=``0``)`**

**`# pattern： 正则模型`**

**`# string ： 要匹配的字符串`**

**`# maxsplit：指定分割个数`**

**`# flags  ： 匹配模式`**



**按照一个字符将全部字符串进行分割**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.split("a", origin) #根据正则匹配分割字符串
    print(r)
    #输出结果 ['hello ', 'lex bcd ', 'lex lge ', 'lex ', 'cd 19']
    #根据a进行分组
[/code]

**将匹配到的字符串作为分割标准进行分割**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex 2acd 19"
    r = re.split("a\w+", origin) #根据正则匹配分割字符串
    print(r)
    #输出结果 ['hello ', ' bcd ', ' lge ', ' 2', ' 19']
    #将匹配到的字符串作为分割标准进行分割
[/code]

**设置分割参数，如果设置了分割次数，分割次数达到后，后面匹配的也不分割了**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex 2acd 19"
    r = re.split("a\w+", origin,2) #设置分割参数，如果设置了分割次数，分割次数达到后，后面匹配的也不分割了
    print(r)
    #输出结果 ['hello ', ' bcd ', ' lge ', ' 2', ' 19']
    #设置分割参数，如果设置了分割次数，分割次数达到后，后面匹配的也不分割了
[/code]

**有分组分割，无分组分割，匹配到作为分割标准的字符串，是不被输出的，如果想同样输出作为分割标准的字符串可以用组来分割，可以理解为组部分，分割后同样被拿出**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex 2acd 19"
    r = re.split("(a\w+)", origin) #有分组分割，无分组分割，匹配到作为分割标准的字符串，是不被输出的，如果想同样输出作为分割标准的字符串可以用组来分割
    print(r)
    #输出结果 ['hello ', 'alex', ' bcd ', 'alex', ' lge ', 'alex', ' 2', 'acd', ' 19']
    #有分组分割，无分组分割，匹配到作为分割标准的字符串，是不被输出的，如果想同样输出作为分割标准的字符串可以用组来分割
[/code]

**  用split()做一个多括号，字符串提取功能，也就是去除字符串里的所有括号**

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "1 - 2 * ( (60-30 +(-4/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2) )"
    while True:
        r = re.split("\(([^()]+)\)", origin,1)#匹配以\(开头,以\)结尾，中间没有[^()]的,+中间除括号外可以是1位或者多位字符，然后通过分组拿到匹配到的（）号里的字符串
        if len(r) == 3: #每一次正则表达式匹配分割后，应该返回的是一个有3个元素的列表，匹配列表元素是否是3个
            a = r[0]    #索引列表拿出列表元素
            b = r[1]    #索引列表拿出列表元素
            c = r[2]    #索引列表拿出列表元素
            xin = a + b + c     #将列表索引出来的字符串重组
            origin = xin        #将列表索引出来的字符串重组后，重新赋值给origin变量进行下次正则匹配
            print(origin)
        else:
            break   #当列表元素不是3个时，说明正则已经处理完括号了，就退出循环
    #输出结果
    # 1 - 2 * ( (60-30 +-4/5 * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2) )
    # 1 - 2 * ( (60-30 +-4/5 * 9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 ) - (-4*3)/ (16-3*2) )
    # 1 - 2 * ( 60-30 +-4/5 * 9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14  - (-4*3)/ (16-3*2) )
    # 1 - 2 * ( 60-30 +-4/5 * 9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14  - -4*3/ (16-3*2) )
    # 1 - 2 * ( 60-30 +-4/5 * 9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14  - -4*3/ 16-3*2 )
    # 1 - 2 *  60-30 +-4/5 * 9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14  - -4*3/ 16-3*2
[/code]



**sub()函数**

**替换匹配成功的指定位置字符串**

**`sub(pattern, repl, string, count``=``0``, flags``=``0``)`**

**`# pattern： 正则模型`**

**`# repl   ： 要替换的字符串`**

**`# string ： 要匹配的字符串`**

**`# count  ： 指定匹配个数`**

**`# flags  ： 匹配模式`**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    r = re.sub("a","替换",origin) #替换匹配成功的指定位置字符串
    print(r)
    #输出
    # hello 替换lex bcd 替换lex lge 替换lex 替换cd 19
[/code]



**subn()函数**

**替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受**

**`subn(pattern, repl, string, count``=``0``, flags``=``0``)`**

**`# pattern： 正则模型`**

**`# repl   ： 要替换的字符串`**

**`# string ： 要匹配的字符串`**

**`# count  ： 指定匹配个数`**

**`# flags  ： 匹配模式`**

[code]

     #!/usr/bin/env python
    # -*- coding:utf8 -*-
    import re
    origin = "hello alex bcd alex lge alex acd 19"
    a,b = re.subn("a","替换",origin) #替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受
    print(a)
    print(b)
    #输出
    # hello 替换lex bcd 替换lex lge 替换lex 替换cd 19
    # 4
[/code]



**元字符表**

.

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** **.** **元字符）可以是任何一个字符，** **匹配任意除换行符** **"\n"**
**外的字符** **(** **在** **DOTALL** **模式中也能匹配换行符** **)**

|

a.c

|

abc  
  
---|---|---|---  
  
\

|

**1.** **反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符），** **2.**
**反斜杠后边跟普通字符实现特殊功能；（即预定义字符），** **3.\2** **引用序号对应的字组**

|

a\\.c;a\\\c

|

a.c;a\c  
  
*

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** ***** **元字符）前面的一个字符可以是** **0** **个或多个原本字符，**
**匹配前一个字符** **0** **或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪，** **如果规则里只有一个分组，尽量避免用** *****
**否则会有可能匹配出空字符串**

|

abc*

|

ab;abccc  
  
+

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** **+** **元字符）前面的一个字符可以是** **1** **个或多个原本字符，**
**匹配前一个字符** **1** **次或无限次，贪婪匹配前导字符有多少个就匹配多少个很贪婪**

|

abc+

|

abc;abccc  
  
?

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** **?** **元字符）前面的一个字符可以是** **0** **个或** **1**
**个原本字符，** **匹配一个字符** **0** **次或** **1** **次，还有一个功能是可以防止贪婪匹配，详情见防贪婪匹配**

|

abc?

|

ab;abc  
  
^

|

[code]

    **字符串开始位置与匹配规则符合就匹配，否则不匹配** **，** **匹配字符串开头。在多行模式中匹配每一行的开头** **，** **^元字符如果写到[]字符集里就是反取**
[/code]

|

^abc

|

abc  
  
$

|

**字符串结束位置与匹配规则符合就匹配，否则不匹配，** **匹配字符串末尾，在多行模式中匹配每一行的末尾**

|

abc$

|

abc  
  
|

|

**|** **或，或就是前后其中一个符合就匹配**

|

abc|def

|

abc

def  
  
{}

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** **  {} ****元字符）前面的一个字符，是自定义字符数，位数的原本字符，**
**{m}** **匹配前一个字符** **m** **次，** **{m,n}** **匹配前一个字符** **m** **至** **n**
**次，若省略** **n** **，则匹配** **m** **至无限次，**
{0,}匹配前一个字符0或多次,等同于*元字符，{+,}匹配前一个字符1次或无限次,等同于+元字符，{0,1}匹配前一个字符0次或1次,等同于?元字符

|

ab{1,2}c

|

abc

abbc  
  
[]

|

**需要字符串里完全符合，匹配规则，就匹配，（规则里的** **  [] ****元字符）对应位置是** **[]** **里的任意一个字符就匹配，**
**字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如** **[abc]** **或** **[a-c]**
**。** **[^abc]** **表示取反，即非** **abc** **。所有特殊字符在字符集中都失去其原有的特殊含义。用** **\**
**反斜杠转义恢复特殊字符的特殊含义。**

|

a[bcd]e

|

abe

ace

ade

  
  
()

|

**也就是分组匹配，** **()** **里面的为一个组也可以理解成一个整体，** **如果** **()** **后面跟的是特殊元字符如** **
(adc)*   ****那么** ***** **控制的前导字符就是** **()** **里的整体内容，不再是前导一个字符**

|

(abc){2}  
a(123|456)c

|

abcabc

a456c  
  
**预定义字符集表，** **可以写在字符集** **[...]** **中** ** **

\d

|

\d匹配任何十进制数，它相当于类[0-9]，\d+如果需要匹配一位或者多位数的数字时用

|

a\bc

|

a1c  
  
---|---|---|---  
  
\D

|

\D匹配任何非数字字符，它相当于类[^0-9]

|

a\Dc

|

abc  
  
\s

|

\s匹配任何空白字符，它相当于类[\t\n\r\f\v]

|

a\sc

|

a c  
  
\S

|

\S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]

|

a\Sc

|

abc  
  
\w

|

\w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]

|

a\wc

|

abc  
  
\W

|

\W匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]

|

a\Wc

|

a c  
  
\A

|

仅匹配字符串开头,同^

|

\Aabc

|

abc  
  
\Z

|

仅匹配字符串结尾，同$

|

abc\Z

|

abc  
  
\b

|

b匹配一个单词边界，也就是指单词和空格间的位置

|

\babc\b  
a\b!bc

|

空格abc空格  
a!bc  
  
\B

|

[^\b]

|

a\Bbc

|

abc  
  


**特殊分组用法表：** **只对正则函数返回对象的有用**

(?P<name>)

|

?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容，在用groupdict()方法打印字符串

|

(?P<id>abc){2}

|

abcabc  
  
---|---|---|---  
  
(?P=name)

|

引用别名为<name>的分组匹配到字符串

|

(?P<id>\d)abc(?P=id)

|

1abc1

5abc5  
  
\<number>

|

引用编号为<number>的分组匹配到字符串

|

(\d)abc\1

|

1abc1

5abc5  
  


**正则匹配模式表**

标志

|

含义  
  
---|---  
  
re.S(DOTALL)

|

使.匹配包括换行在内的所有字符  
  
re.I（IGNORECASE）

|

使匹配对大小写不敏感  
  
re.L（LOCALE）

|

做本地化识别（locale-aware)匹配，法语等  
  
re.M(MULTILINE)

|

多行匹配，影响^和$  
  
re.X(VERBOSE)

|

该标志通过给予更灵活的格式以便将正则表达式写得更易于理解  
  
re.U

|

根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B  
  
 正则小示例

1、匹配电话号码

[code]

    p = re.compile(r'\d{3}-\d{6}')
    print(p.findall('010-628888'))
[/code]

2、匹配IP

[code]

    re.search(r"(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5]\.)","192.168.1.1")
[/code]

_ _

[code]

     IP：
    ^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$
    手机号：
    ^1[3|4|5|8][0-9]\d{8}$
    邮箱：
    [a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+
[/code]





**正则表达式重点**

**一、**

**r原生字符**

**将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r**



**二、**

**正则表达式，返回类型为表达式对象的**

**如： <_sre.SRE_Match object; span=(6, 7), match='a'>  **

**返回对象的，需要用正则方法取字符串，**

**方法有**

**group() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2  
groups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果  
groupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果**



**三、**

**匹配到的字符串里出现空字符**

**注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是*就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用*否则会有可能匹配出空字符串**



四、

()分组

**注意：分组的意义，就是在匹配成功的字符串中，在提取()里，组里面的字符串**



**五、**



[code]

    **?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()**
[/code]





[code]

    ** **
[/code]

