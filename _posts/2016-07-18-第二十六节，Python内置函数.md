---
layout: post
title: " 第二十六节，Python内置函数 "
author: "Ans1ble"
header-style: text
tags:
      - Python
---

Python3.0内置函数

![](https://images2015.cnblogs.com/blog/955761/201607/955761-20160718123716060-1062417374.png)



[code]

    **abs() 取数字的绝对值,也就是无论是正数还是负数取它的绝对值  
     格式：abs(目标变量)  
    返回：数字类型**
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #abs() 取数字的绝对值,也就是无论是正数还是负数取它的绝对值
    a = 123
    b = abs(a)
    print(b)
    #输出 123
    
    a1= -123
    b1 = abs(a1)
    print(b1)
    #输出 123
[/code]



**all() 接收可迭代类型，循环参数，如果每个元素都为真，那么all的返回值为真，有一个元素为假返回的都是假**

**格式：all(目标变量)**

**假数据有，0（数字），None（返回值），"" (空字符串)，[] (空列表)，（） （空元组），{} （空字典）**

**返回：布尔值**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #all() 接收可迭代类型，循环参数，如果每个元素都为真，那么all的返回值为真，有一个元素为假返回的都是假
    #假数据有，0（数字），None（返回值），"" (空字符串)，[] (空列表)，（） （空元组），{} （空字典）
    
    #列1
    a = [1,"123",[123,456],(123,456),{"k1":123,"k2":456}]
    f1 = all(a)
    print(f1)
    #输出 True （真）
    
    #列2
    b = [0,"你好",[123,456],(123,456),{"k1":123,"k2":456}]
    f2 = all(b)
    print(f2)
    #输出 False （假）说明：里面的类型中有一个或者多个为假
[/code]



[/code]

[code]

    **any() 接收可迭代类型，循环参数，如果有一个元素都为真，那么all的返回值为真，全部为假才返回假  
     格式：any(目标变量)  
     **假数据有，0（数字），None（返回值），"" (空字符串)，[] (空列表)，（） （空元组），{} （空字典）**  
     返回：布尔值  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #any() 接收可迭代类型，循环参数，如果有一个元素都为真，那么all的返回值为真，全部为假才返回假
    #假数据有，0（数字），None（返回值），"" (空字符串)，[] (空列表)，（） （空元组），{} （空字典）
    
    #列1
    a = [0,"1",[],(),{}]    #其中有1个为真
    f1 = any(a)
    print(f1)
    #输出 True （真）
    
    #列2
    b = [0,"",[],(),{}]     #全部为假
    f2 = all(b)
    print(f2)
    #输出 False （假）说明：里面的类型全部为假
[/code]



[code]

    **ascii() 根据对象，在对象类中找到 _repr_ 获取其返回值，中文返回 ascii()码  
    ** **格式： ascii(目标变量)  
    ** _ **返回：对应的类型，中文返回**_ **ascii()码  
    **
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #ascii() 根据对象，在对象类中找到 _repr_ 获取其返回值，中文返回ascii()码
    a = 1234
    b = ascii(a)
    print(b)
    #返回 1234
    
    #如果是中文字符串转换成ascii码返回
    a1 = "林贵秀"
    b1 = ascii(a1)
    print(b1) #中文字符串转换成ascii码返回
    #返回 '\u6797\u8d35\u79c0'
[/code]

[code]

    ** **
[/code]

[code]

    **bin() 二进制表示,十进制转换二进制  
     格式：bin(目标变量)  
    返回：二进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #bin() 二进制表示
    a = 12
    b = bin(a)
    print(b)
    #返回 0b1100 （0b表示二进制的意思）
[/code]

[/code]

[code]

**oct() 八进制表示，十进制转换八进制  **

**格式：oct(目标变量)**

**返回：八进制**

[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #oct() 八进制表示
    a = 123
    b = oct(a)
    print(b)
    #返回 0173 （0表示八进制的意思）
[/code]

[/code]

[code]

    **int() 十进制表示 **，十进制转换十进制**  
     格式：int(目标变量)  
    返回：十进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int() 十进制表示
    a = 123987
    b = int(a)
    print(b)
    #返回 123987 （表示十进制的意思）
[/code]

[/code]

[code]

    **hex() 十六进制表示 **，十进制转换十六进制**  
     格式:hex(目标变量)  
    返回：十六进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #hex() 十六进制表示
    a = 123987
    b = hex(a)
    print(b)
    #返回 0x1e453 （0x表示十进制的意思）
[/code]

[/code]

[code]

    **int()  二进制转换成十进制  
     格式：int(目标变量,base=2 )  
    返回：十进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int()  二进制转换成十进制
    a = "0b1100"
    b = int(a,base=2)
    print(b)
    #返回 12 表示十进制的意思
[/code]

[/code]

[code]

    **int()  八进制转换成十进制  
     格式：int(目标变量,base=8 )  
    返回：十进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int()  八进制转换成十进制
    a = "0173"
    b = int(a,base=8)
    print(b)
    #返回 123 表示十进制的意思
[/code]



[code]

    **int()  十进制转换成十进制  
     格式：int(目标变量,base=10 )  
    返回：十进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int()  十进制转换成十进制
    a = "123987"
    b = int(a,base=10)
    print(b)
    #返回 123987 表示十进制的意思
[/code]



[code]

    **int()  十六进制转换成十进制  
     格式：int(目标变量,base=16 )  
    返回：十进制  
    **
[/code]

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int()  十六进制转换成十进制
    a = "0x1e453"
    b = int(a,base=16)
    print(b)
    #返回 123987 表示十进制的意思
[/code]



**bool() 判断真假，把一个对象转换成布尔值**  
 **假数据有，0（数字），None（返回值），"" (空字符串)，[] (空列表)，（） （空元组），{} （空字典）**  
 **格式：bool(目标变量)**  
 **返回：假返回False 真返回True**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #bool() 判断真假，把一个对象转换成布尔值
    a1 = ""
    b = bool(a1)
    print(b)
    #返回 False 表示a1空字符串为假
[/code]



**bytes() 字符串转换成字节**  
 **格式：bytes(目标变量,encoding="utf-8")**  
 **返回：字节码**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #bytes() 字符串转换成字节
    a = "林贵秀"
    b = bytes(a, encoding = "utf-8")
    print(b)
    #返回 b'\xe6\x9e\x97\xe8\xb4\xb5\xe7\xa7\x80'  字节
[/code]



**decode()将二进制字节类型解码成字符串**

**格式：字节码变量. **decode("utf-8")  ****

[code]

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    #bytes() 字符串转换成字节
    a = "林贵秀"
    b = bytes(a, encoding = "utf-8")
    print(b)
    #返回 b'\xe6\x9e\x97\xe8\xb4\xb5\xe7\xa7\x80'  字节
    f = b.decode("utf-8")
    print(f)
    #输出
    # b'\xe6\x9e\x97\xe8\xb4\xb5\xe7\xa7\x80'
    # 林贵秀
[/code]





**str() 将字节转换成字符串**  
 **格式：str(目标变量,encoding="utf-8")**  
 **返回：字符串**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    """str() 将字节转换成字符串"""
    #bytes() 字符串转换成字节
    a = "林贵秀"
    b = bytes(a, encoding = "utf-8")
    print(b)
    #返回 b'\xe6\x9e\x97\xe8\xb4\xb5\xe7\xa7\x80'  字节
    
    #str() 将字节转换成字符串
    c = str(b, encoding = "utf-8")
    print(c)
    #返回 林贵秀 字符串
[/code]





**bytearray() 将字符串转换成字节列表**  
 **格式：bytearray(目标变量,encoding="utf-8")**  
 **返回：字节列表**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #bytearray() 字节列表
    a = "林贵秀"
    b = bytearray(a, encoding="utf-8")
    print(b)
    #返回 bytearray(b'\xe6\x9e\x97\xe8\xb4\xb5\xe7\xa7\x80') 字节列表
    
    #字节列表也可以用str()转换成字符串
    c = str(b, encoding="utf-8")
    print(c)
    #返回 林贵秀 字符串
[/code]





**chr() 将十进制ascii码转换成对应的（英文，字符，数字）**  
 **格式：chr(目标变量)**  
 **返回：对应的（英文，字符，数字）**

**详情见： **ascii** 码对照表**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #chr() 将十进制ascii码转换成对应的（英文，字符，数字）
    a = 77
    b = chr(a)
    print(b)
    #返回 M  ascii码对应的（英文，字符，数字）
[/code]





**ord() 将（英文，字符，数字）转换成十进制对应的ascii码**  
 **格式：ord(目标变量)**  
 **返回：十进制对应的ascii码**

****详情见： **ascii** 码对照表****



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #ord() 将（英文，字符，数字）转换成十进制对应的ascii码
    a = "M"
    b = ord(a)
    print(b)
    #返回 77  十进制对应的ascii码
[/code]



**random 随机数模块**  
 **格式：**  
 **import random 引入随机模块文件**  
 **random.randrange(65,91) 调用随机函数random.randrange(随机数开始范围,随机数结束范围)**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    """实现随机数"""
    import random   #引入随机模块文件
    f1 = random.randrange(65,91)    #调用随机函数random.randrange(随机数开始范围,随机数结束范围)
    print(f1)   #返回一个65至91之间的随机数
[/code]





[code]

    **实现随机验证码  
    **
[/code]

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    """实现随机验证码"""
    
    """实现随机数"""
    import random   #引入随机模块文件
    f1 = random.randrange(65,91)    #调用随机函数random.randrange(随机数开始范围,随机数结束范围)
    print(f1)   #返回一个65至91之间的随机数
    
    """实现8位数字随机数"""
    suij = ""   #统计随机数
    for i in range(4):  #循环4次
        rad = random.randrange(65,91)   #每一次循环随机一个65至91之间的一个数赋值rad变量
        c = str(rad)    #将每次得到的随机数转换成字符串类型
        suij = suij + c     #将转换成字符串类型的随机数赋值给，统计随机数
    print(suij)     #打印出统计随机数
    
    """实现4位字母随机数130"""
    suij2 = ""      #统计随机数
    for i in range(4):      #循环4次
        rad = random.randrange(65,91)       #每一次循环随机一个65至91之间的一个数赋值rad变量
        c = chr(rad)        #将每次得到的随机数以十进制的ascii码转换成对应字母（ascii码字母范围是65-91）
        suij2 += c      #将转换的字母赋值给，统计随机数
    print(suij2)        #打印出统计随机数
    
    """实现随机数字字母的组合"""
    suij3 = ""      #统计随机数
    for i in range(4):      #循环4次
        rad1 = random.randrange(0,6)        #每一次循环随机一个0至6之间的一个数
        if rad1 == 1 or rad1 == 3:          #判断如果rad1变量随机数等于1或者等于3
            rad2 = random.randrange(65,91)      #每一次循环随机一个65至91之间的一个数
            c1 = str(rad2)      #将随机数转换成字符串
            suij3 = suij3 + c1      #将转换的字符串赋值给，统计随机数
        else:       #如果rad1变量随机数不等于1或者3
            rad3 = random.randrange(65,91)      #每一次循环随机一个65至91之间的一个数
            c2 = chr(rad3)      #将随机到的数以十进制的ascii码转换成对应字母
            suij3 = suij3 + c2      #将转换的字母赋值给，统计随机数
    print(suij3)        #打印出统计随机数
[/code]

[/code]

[code]



**callable() 一个对象是否可以被执行，也就是判断一个对象是否可以执行一个功能，如判断函数**  
 **格式：callable(目标变量)**  
 **返回：布尔值，可以执行返回True,不可以执行返回False**



[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #callable() 一个对象是否可以被执行，也就是判断一个对象是否可以执行一个功能，如判断函数
    def f1(a,b):
        c = a + b
        return c
    f1(5,5)
    r = callable(f1)
    print(r)
    #返回 True 表示可执行对象
[/code]



**dict() 字典，创建字典**  
 **格式：dict(目标变量)**  
 **返回：字典**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #dict() 字典，创建字典
    #创建字典
    a = dict({"k1":123,"k2":456,"k3":789})
    print(a)
    #返回 {'k3': 789, 'k1': 123, 'k2': 456}
[/code]



**dir() 查看一个对象的类库所有功能**  
 **格式：dir(目标变量)**  
 **返回：对象的类库详情**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #dir() 查看一个对象的类库所有功能
    a = []
    b = dir(a)
    print(b)
    #返回：对象的类库详情
[/code]



**help() 查看一个类的类库功能详情**  
 **格式：help(类名称)**  
 **返回：一个类的类库功能详情**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #help() 查看一个类的类库功能详情
    a = help(str)
    print(a)
    #返回 一个类的类库功能详情
[/code]



**divmod() 除数，判断除数结果，如果结果是整数返回整数加余数0，如果结果有小数返回整数加余数1**  
 **格式：divmod(除数,被除数)**  
 **返回：整数加余数1 ， **整数加余数0****

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #divmod() 除数，判断除数结果，如果结果是整数返回整数加余数0，如果结果有小数返回整数加余数1
    #除数结果是整数列
    a = divmod(10,5)
    print(a)
    #返回 (2, 0)
    
    #除数结果有小数列
    b = divmod(10,3)
    print(b)
    #返回 (3, 1)
[/code]



**enumerate() 自定义有序类型的起始索引，如：列表，元组等**  
 **格式：(目标变量,起始索引位置数)**  
 **返回：对应类型的索引自定义位置开始**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #enumerate() 自定义有序类型的起始索引，如：列表，元组等
    #列1
    a = [123,456,789]
    for k,v in enumerate(a,1):
        print(k,v)
    #返回
    #1 123
    #2 456
    #3 789
    
    #列2
    b = [987,654,321]
    c = enumerate(b,1)
    for k,v in c:
        print(k,v)
    #返回
    #1 987
    #2 654
    #3 321
[/code]



**eval() 计算字符串类型的算数**  
 **格式：eval(目标变量,赋值字典)**  
 **返回：计算结果**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #eval() 计算字符串类型的算数
    #列1
    a = "3 + 2 - 5 + 1"     #字符串类的表达式
    b = eval(a)     #计算字符串类的表达式
    print(b)    #返回结果
    #返回 1
    
    #列2
    b1 = eval("f + 5",{"f":8})      #f+5,相当于f是一个变量+5，后面可以传一个字典，就相当于赋值f变量等于8
    print(b1)       #返回结果
    #返回 13
[/code]



**exec() 执行字符串类型的代码**  
 **格式：exec(目标变量)**  
 **返回：无返回值，只执行字符串类型的代码**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #exec() 执行字符串类型的代码
    #列1
    a1 = "for i in range(8): print(i)"      #字符串类型的一个8次循环
    b1 = exec(a1)   #执行字符串代码
    
    #列2
    a = "for i in range(x): print(i)"   #字符串类型的一个8次循环
    b = exec(a,{"x":8})     #后面可以传一个字典，就相当于赋值x变量等于8
[/code]



**filter() 帅选 **一个可迭代对象**
，循序一个可迭代对象，将每次循环到的元素传入一个判断函数，判断函数返回True就将此元素保留，返回False的元素不保留**  
 **格式：filter(函数, **可迭代对象** )**  
 **返回：函数返回True的元素**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #filter() 循序一个 **可迭代对象** ，将每次循环到的元素传入一个判断函数，判断函数返回True就将此元素保留，返回False的元素不保留
    #列1
    def f1(x):
        if x > 5:   #判断函数传入的参数是否大于5
            return True     #如果大于5返回True
        else:
            return False    #如果不大于5返回False
    a = filter(f1,[1,2,3,4,5,6,7,8,9])      #循环 **可迭代对象** 每次循环到的元素传入f1函数，每次传入函数返回True的元素保留给a变量，返回False 的元素不保留
    for i in a:     #循环出保留的元素
        print(i)    #打印出保留的元素
    #打印出
    # 6
    # 7
    # 8
    # 9
    
    #列2
    #用lambda的表达式创建函数
    a1 = filter(lambda x: x > 5 ,[1,2,3,4,5,6,7,8,9])   #循环 **可迭代对象** 每次循环到的元素传入f1函数，每次传入函数返回True的元素保留给a变量，返回False 的元素不保留
    for i in a1:    #循环出保留的元素
        print(i)    #打印出保留的元素
    #打印出
    # 6
    # 7
    # 8
    # 9
[/code]



**map() 对一个可迭代对象的每个元素做一种操作，返回以处理后的元素**  
 **格式：map(函数，可迭代对象)**  
 **返回：返回以处理后的元素**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #map() 对一个可迭代对象的每个元素做一种操作，返回以处理后的元素
    #列1
    def f1(x):
        return x + 100  #将函数接收到的参数加100返回
    a = map(f1,[1,2,3,4,5])     #循环列表将每次循环的元素传入函数，将每次函数返回结果赋值给a变量
    for i in a:     #循环出结果赋值的变量
        print(i)    #打印结果
    #输出
    # 101
    # 102
    # 103
    # 104
    # 105
    
    #列2
    #用lambda表达式创建函数
    a1 = map(lambda x: x + 100, [1,2,3,4,5])
    for i in a1:
        print(i)
    #输出
    # 101
    # 102
    # 103
    # 104
    # 105
[/code]



**globals() 获取当前代码里的所有全局变量**  
 **格式：print(globals())**  
 **返回：当前代码里的所有全局变量**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #globals() 获取当前代码里的所有全局变量
    a = 123
    b = 456
    c = 789
    print(globals())
    #返回：当前代码里的所有全局变量
[/code]



**locals() 获取当前代码里的所有局部变量**  
 **格式：print(locals())**  
 **返回：当前代码里的所有局部变量**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #locals() 获取当前代码里的所有局部变量
    def f1():
        a = 123
        b = 456
        c = 789
        print(locals())     #获取当前代码里的所有局部变量
    f1()
[/code]



**hash() 计算一个字符串的哈希值**  
 **格式：hash(目标变量)**  
 **返回：哈希值**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #hash() 计算一个字符串的哈希值
    a = "ihdaho;uybvy8h9adghoda"
    b = hash(a)
    print(b)
    #返回 2278432038003157021 哈希值
[/code]



**help() 查看类的帮助信息**  
 **格式：help(type(a))**  
 **返回：帮助信息**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #help() 查看类的帮助信息
    a = "ihvfijwj"
    b = help(type(a))
    print(b)
    #返回：帮助信息
[/code]



**id() 获取对象的内存地址**  
 **格式：id(目标变量)**  
 **返回：对象内存地址**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #id() 获取对象的内存地址
    a = "ewjwehnig"
    b = id(a)
    print(b)
    #返回：对象内存地址
[/code]



**input() 等待用户输入**  
 **格式：变量 = input()**  
 **返回：用户输入信息**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #input() 等待用户输入
    a = input()
    print(a)
    #返回：用户输入信息
[/code]



**int() 创建或者转换整数类型**  
 **格式：int(目标变量)**  
 **返回：整数**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #int() 创建或者转换整数类型
    #创建整数
    a = int(1234)
    print(a)
    
    #转换整数
    b = "1234"
    c = int(b)
    print(c)
    #返回：整数
[/code]



**isinstance() 判断一个对象是否是某个类型**  
 **格式：isinstance(目标对象,类型)**  
 **返回：如果是对应的类型True，不是对应的类型False**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #isinstance() 判断一个对象是否是某个类型
    a = "林贵秀"
    b = isinstance(a,str)
    print(b)
    #返回 True
[/code]



**iter() 创建可迭代的对象，结合next()取出里面的每个元素**  
 **格式：iter(目标变量)**  
 **返回：可迭代类型**  
 **可结合next()取出里面的每个元素**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #iter() 创建可迭代的对象
    a = "rghrthrhkjhtr"
    b = iter(a) #创建可迭代的对象
    print(b)
    c1 = next(b) #取出里面一个元素
    print(c1)
    c2 = next(b) #取出里面一个元素
    print(c2)
    c3 = next(b) #取出里面一个元素
    print(c3)
    # 返回：可迭代类型
    # 可结合next()取出里面的每个元素
[/code]



**next()取出可迭代类型里面的每个元素，结合iter()使用**  
 **格式：next(目标对象)**  
 **返回：可迭代类型的一个元素**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #iter() 创建可迭代的对象
    a = "rghrthrhkjhtr"
    b = iter(a) #创建可迭代的对象
    print(b)
    c1 = next(b) #取出里面一个元素
    print(c1)
    c2 = next(b) #取出里面一个元素
    print(c2)
    c3 = next(b) #取出里面一个元素
    print(c3)
    # 返回：可迭代类型
    # 可结合next()取出里面的每个元素
[/code]



**len() 判断一个可迭代对象里面有多少个元素**  
 **格式：len(目标对象)**  
 **返回：可迭代对象里面元素的数量**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #len() 判断一个可迭代对象里面有多少个元素
    a = "12345"
    b = len(a)
    print(b)
    # 返回：可迭代对象里面元素的数量
[/code]



**max() 取一个可迭代对象的最大值**  
 **格式：max(目标变量)**  
 **返回：最大值**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #max() 取一个可迭代对象的最大值
    a = "128345"
    b = max(a)
    print(b)
    # 返回：最大值
[/code]



**min() 取一个可迭代对象的最小值**  
 **格式：min(目标变量)**  
 **返回：最小值**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #min() 取一个可迭代对象的最小值
    a = "128345"
    b = min(a)
    print(b)
    # 返回：最小值
[/code]



**pow() 求一个数的对少次方**  
 **格式：pow(要求的数,多少次方)**  
 **返回：一个数的次方**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #pow() 求一个数的对少次方
    a = pow(2,10) #2的10次方
    print(a)
    #返回 1024
[/code]



**property() 打印结果**  
 **格式：property(目标变量)**  
 **返回：结果**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #property() 打印结果
    a = 12345
    print(a)
    #返回 12345 结果
[/code]



**range() 自动创建一个数字列表，py3.0以上版本需要for循环后才创建**  
 **格式：range(开始数字，结束数字)**  
 **返回：需要for循环后返回创建的元素**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #range() 自动创建一个列表
    a = range(1,10) #如果传一个参数，默认从0开始
    for i in a:
        print(i)
    #返回 需要for循环后返回创建的元素
[/code]



**repr() 在对象类中找到 _repr_ 获取其返回值，返回对应的类型**  
 **格式：repr（目标变量）**  
 **返回：对应的类型**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #repr（）在对象类中找到 _repr_ 获取其返回值，返回对应的类型
    a = 1234
    b = repr(a)
    print(b)
    #返回 1234
    
    
    a1 = "林贵秀"
    b1 = repr(a1)
    print(b1)
    #返回 '林贵秀'
[/code]



**reversed() 对可迭代类型的元素排序进行反转，需要for循环后返回**  
 **格式：reversed(目标变量)**  
 **返回：需要for循环后返回，将元素进行反转排序后返回**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #reversed() 对可迭代类型的元素排序进行反转，需要for循环后返回
    a = "1234"
    b = reversed(a)
    for i in b:
        print(i)
    # 返回
    # 4
    # 3
    # 2
    # 1
[/code]



**round() 四舍五入**  
 **格式：round(目标变量)**  
 **返回：四舍五入**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #round() 四舍五入
    #四舍
    a = 3.4
    b = round(a)
    print(b)
    #返回 3
    
    #五入
    a1 = 5.5
    b1 = round(a1)
    print(b1)
    #返回 6
[/code]



**set() 创建或转换无序集合**  
 **格式：set(目标变量)**  
 **返回：无序集合**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #set() 创建或转换无序集合
    #创建结合
    a1 = set({1,2,3})
    print(a1)
    #返回 {1, 2, 3}
    
    #转换集合
    a = [1,2,3,4,5]
    b = set(a)
    print(b)
    #返回 {1, 2, 3, 4, 5}
[/code]



**sum() 将一个可迭代对象的数字元素求和**  
 **格式：sum(目标变量)**  
 **返回：求和**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #sum() 将一个可迭代对象的数字元素求和
    a = [11,22,33,44]
    b = sum(a)
    print(b)
    #返回 110 求和
[/code]



**tuple() 创建或转换元组**  
 **格式：tuple(目标变量)**  
 **返回：元组**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #tuple() 创建或转换元组
    #创建元组
    a = tuple((11,22,33,44))
    print(a)
    #返回 (11, 22, 33, 44)
    
    #转换元组
    a1 = [11,22,33,44]
    b1 = tuple(a1)
    print(b1)
    #返回 (11, 22, 33, 44)
[/code]



**type() 查看一个对象的类型**  
 **格式：type(目标变量)**  
 **返回：类型**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #type() 查看一个对象的类型
    a = "你好"
    b = type(a)
    print(b)
    #返回类型 <class 'str'>
[/code]



**zip() 将两个列表的元素，组合成两个元素为一对元组，需要for循环后返回**  
 **格式：zip(列表，列表)**  
 **返回：需要for循环后返回，两个元素为一对元组**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #zip() 将两个列表的元素，组合成两个元素为一对元组，需要for循环后返回
    a = [1,2,3,4,5]
    b = ["a","b","c","d","e"]
    c = zip(a,b)
    print(c)    #<zip object at 0x0000012584DA0F88>
    for i in c:
        print(i)
    #返回
    # (1, 'a')
    # (2, 'b')
    # (3, 'c')
    # (4, 'd')
    # (5, 'e')
[/code]



**sorted() 对可迭代对象排序，注意可迭代对象元素一定要是同一类型，否则不能排序**  
 **格式：sorted(目标变量)**  
 **返回：排序后的对应对象**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #sorted() 对可迭代对象排序，注意可迭代对象元素一定要是同一类型，否则不能排序
    #数字排序，数字从小到大排序
    a = [6,3,8,2,9,7,5]
    b = sorted(a)
    print(b)
    #返回 [2, 3, 5, 6, 7, 8, 9]
    
    #字母排序，字母按照顺序排序
    a1 = ["d","f","s","e","a","u","g","l"]
    b1 =sorted(a1)
    print(b1)
    #返回 ['a', 'd', 'e', 'f', 'g', 'l', 's', 'u']
    
    #字符串排序，是按照字符串的字节码数字和字母的 **ascii码** 排序的
    a2 = "自贡玉秀文化传播有限公司"
    b2 = sorted(a2)
    print(b2)
    #返回 ['传', '公', '化', '司', '播', '文', '有', '玉', '秀', '自', '贡', '限']
    
    for i in b2:
        print(bytes(i,encoding="utf-8"))    #查看字符串的字节码
[/code]



**文件操作**  
 **文件操作的步骤**  
 **1.打开文件： open()打开文件**  
 **2.操作文件： read()读出文件，write()写入文件**  
 **3.关闭文件： close()关闭文件**



**open() 打开一个文件**  
 **格式：句柄变量 = open(要打开的文件名或文件路径，打开模式，编码)**  
 **注意：默认是只读模式**  
 **注意：编码只有在普通模式的时候用（3.0版本默认是utf-8编码），字节码模式不需要编码因为基层就是字节码保存的**  
 **返回：文件句柄**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #open() 打开一个文件
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r模式（只读）打开，以utf-8编码
    print(f)    #打印文件句柄，<_io.TextIOWrapper name='h.log' mode='r' encoding='utf-8'>
    f1 = f.read()   #read()读出文件内容
    f.close()   #关闭文件
    print(f1)   #读出文件内容，tjhutrjtr
[/code]



**read() 读出文件内容**  
 **格式：句柄变量.read(位数从指针位置开始向后读多少位)  默认全部读出**  
 **返回：文件里的内容**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #read() 读出文件内容
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r模式（只读）打开，以utf-8编码
    print(f)    #打印文件句柄，<_io.TextIOWrapper name='h.log' mode='r' encoding='utf-8'>
    f1 = f.read()   #read()读出文件内容
    f.close()   #关闭文件
    print(f1)   #读出文件内容，tjhutrjtr
[/code]



**write() 写入文件**  
 **格式：句柄变量.write(要写入的内容)**  
 **返回：无返回，将内容写入文件**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #write() 写入文件
    f = open("h.log", "w", encoding="utf-8")    #打开h.log文件，以r模式（只读）打开，以utf-8编码
    f1 = f.write("林贵秀")   #write()写入文件内容
    f.close()   #关闭文件
[/code]



**close() 关闭文件**  
 **格式：句柄变量.close()**  
 **返回：无，关闭打开的文件**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #read() 读出文件内容
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r模式（只读）打开，以utf-8编码
    print(f)    #打印文件句柄，<_io.TextIOWrapper name='h.log' mode='r' encoding='utf-8'>
    f1 = f.read()   #read()读出文件内容
    f.close()   #关闭文件
    print(f1)   #读出文件内容，tjhutrjtr
[/code]





**打开文件的模式有：**

  * **r ，只读模式【默认】**
  * 
[code]     #!/usr/bin/env python

    # -*- coding:utf-8 -*-
    #r ，只读模式【默认】
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r模式（只读）打开，以utf-8编码
    f2 = f.read()   #read()读出文件
    print(f2)
    f.close()   #关闭文件
    # 只能读，不能写入
[/code]

 下面相同原理

  * **w，只写模式【不可读；不存在则创建；存在则清空内容；】**
  * **x， 只写模式【不可读；不存在则创建，存在则报错】**
  * **a， 追加模式【 **不** 可读；   不存在则创建；存在则只追加内容；】**

**"+" 表示可以同时读写某个文件**

  * **r+， 读写【可读，可写】**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #r ，只读模式【默认】
    f = open("h.log", "r+", encoding="utf-8")    #打开h.log文件，以r+模式（读写）打开，以utf-8编码
    f2 = f.read()   #read()读出文件
    print(f2)
    f.write("9444") #写入文件
    f.close()   #关闭文件
    # 可读，可写
[/code]



下面相同原理



  * **w+，写读【可读，可写， **不存在则创建；存在则清空内容；** 】**
  * **x+ ，写读【可读，可写， **不存在则创建，存在则报错** 】**
  * **a+， 写读【可读，可写， **不存在则创建；存在则只追加内容；** 】**

**  "b"表示以字节的方式操作， **以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型****

******  注：以b方式打开时，读取到的内容是字节类型（不需要编码），写入时也需要提供字节类型（需要用 **bytes()转换成字节写入**
）******

  * **rb 或 r+b 【原有基础上增加字节码模式】**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #r+b 读写字节方式
    f = open("h.log", "r+b")    #打开h.log文件，以r+b模式（读写字节方式）
    f2 = f.read()   #read()读出文件内容字节
    f3 = str(f2, encoding="utf-8")  #将字节转换成字符串
    print(f3)   #打印出字符串
    
    a = "你好"
    b = bytes(a,encoding="utf-8")   #注意：字节模式写入前一定要转换成字节
    f.write(b)  #写入文件
    f.close()   #关闭文件
    # 可读，可写
[/code]



下面相同原理



  * **wb 或 w+b   **【原有基础上增加字节码模式】** **
  * **xb  或 w+b   **【原有基础上增加字节码模式】****
  * **ab  或 a+b   **【原有基础上增加字节码模式】****

** **



**文件指针**  
 **操作文件，写入内容或者读出内容都是从指针位置开始向后操作的。**  
 **指针位置在开始位置后面的内容就可以读出，指针位置在结束的位置后面是空的此时读出就是空白**

**写入内容后指针就停留在写入内容的结束位置，追加模式写入内容是先将指针调到结束位置写入，写入后停留在写入结束位置**  
 **根据打开文件的模式不同指针位置不同，**



** **



**tell() 查看文件指针位置**  
 **格式：句柄变量.tell()**  
 **返回：指针位置**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #tell() 查看文件指针位置
    #如：h.log里有一串字符串"自贡玉秀文化传播有限公司"
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r只读模式，以utf-8编码
    f1 = f.tell()   #tell()获取文件指针位置，注意：中文字符一个汉字算3个指针
    print(f1)   #打印出指针位置
    
    f.seek(9)   #自定义文件指针位置
    f2 = f.tell()   #tell()获取文件指针位置，注意：中文字符一个汉字算3个指针
    print(f2)   #打印出指针位置
    
    f3 = f.read()   #读取文件内容
    print(f3)   #打印出文件内容
    f.close()   #关闭文件
[/code]



**seek() **自定义** 文件指针位置**  
 **格式：句柄变量.seek(自定义指针位置) 默认指针位置0**  
 **返回：无， **自定义** 文件指针位置**

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #tell() 查看文件指针位置
    #如：h.log里有一串字符串"自贡玉秀文化传播有限公司"
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r只读模式，以utf-8编码
    f1 = f.tell()   #tell()获取文件指针位置，注意：中文字符一个汉字算3个指针
    print(f1)   #打印出指针位置
    
    f.seek(9)   #自定义文件指针位置
    f2 = f.tell()   #tell()获取文件指针位置，注意：中文字符一个汉字算3个指针
    print(f2)   #打印出指针位置
    
    f3 = f.read()   #读取文件内容
    print(f3)   #打印出文件内容
    f.close()   #关闭文件
[/code]



**flush() 刷新文件内部缓冲区（将内容刷到硬盘文件里）**  
 **格式：句柄变量.flush()**  
 **返回：无，将内容刷到硬盘文件里**

 下面是将内容刷到硬盘文件里，与不将内容刷到硬盘文件里的区别

1不将内容刷到硬盘文件里

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #flush() 刷新文件内部缓冲区（将内容刷到硬盘文件里）
    #不将内容刷到硬盘文件里
    f = open("h.log", "w", encoding="utf-8")    #打开h.log文件，以w只写，以utf-8编码
    f.write("林贵秀")  #写入内容
    input()     #等待用户输入，进程没结束
    f.close()   #关闭文件
    #如上列说明，等待用户输入，只要用户没有输入信息确认进程就没结束，上面的内容就不会写入文件
[/code]

2将内容刷到硬盘文件里

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #flush() 刷新文件内部缓冲区（将内容刷到硬盘文件里）
    f = open("h.log", "w", encoding="utf-8")    #打开h.log文件，以w只写，以utf-8编码
    f.write("林贵秀")  #写入内容
    f.flush()   #将内容刷到硬盘文件里
    input()     #等待用户输入，进程没结束
    f.close()   #关闭文件
    #如上列说明，等待用户输入，只要用户没有输入信息确认进程就没结束，上面的内容也会写入文件
[/code]



**readline() 仅读取一行数据，后面行的数据不读取**  
 **格式：句柄变量.readline()**  
 **返回：仅返回文件里一行数据**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #readline() 仅读取一行数据
    f = open("h.log", "r", encoding="utf-8")    #打开h.log文件，以r只读模式，以utf-8编码
    f1 = f.readline()   #readline() 仅读取一行数据,后面行的数据不读取
    print(f1)
    f.close()   #关闭文件
[/code]



**truncate() 截断数据，仅保留指针之前数据，指针之后的数据删除**  
 **格式：句柄变量.truncate()**  
 **返回：仅保留指针之前数据，指针之后的数据删除**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #truncate()  截断数据，仅保留指针之前数据
    #如文件里有:123456789
    f = open("h.log", "r+", encoding="utf-8")    #打开h.log文件，以r+读写模式，以utf-8编码
    print(f.tell())     #查看文件指针
    f.seek(5)   #将文件指针定位到第5个位置
    print(f.tell())     #查看文件指针
    f.truncate()   #truncate()  截断数据，仅保留指针之前数据，指针之后的数据删除
    f.close()   #关闭文件
    #最后文件里是 12345 后面的被删除了
[/code]



**for **循环文件里的内容，** 文件句柄是可以被循环的，适合大文件读取好处是节省内存，相当于一行一行的读的，（推荐）**  
 **格式：句柄变量 = 打开文件**  
 **for 循环**  
 **返回：文件里的内容**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    #for 文件句柄是可以被循环的，循环文件里的内容，适合大文件读取好处是节省内存，相当于一行一行的读的，
    f = open("h.log", "r+", encoding="utf-8")    #打开h.log文件，以r+读写模式，以utf-8编码
    for i in f:
        print(i)
    f.close()   #关闭文件
[/code]



**with 自动打开文件，对文件操作后，自动关闭文件,不用写关闭文件函数，而且支持同时打开两个文件（推荐）**  
 **格式：with open("文件路径","打开模式") as 句柄变量:**  
 **返回：句柄变量**

[code]

     #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    # with 自动打开文件，对文件操作后，自动关闭文件（推荐）
    # 格式：with open("文件路径","打开模式") as 句柄变量:
    # 返回：句柄变量
    with open("h.log", "r+", encoding="utf-8") as f:    #自动打开文件，对文件操作后，自动关闭文件
        a = f.read()    #读出文件内容
        print(a)    #打印出文件内容
[/code]

列2 同时打开两个文件，将一个文件的内容写入另外一个文件  
假如原始文件很大，所以通过循环文件句柄，读一行写一行到新文件，减少内存使用率

[code]

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    # 列2 同时打开两个文件，将一个文件的内容写入另外一个文件
    # 假如原始文件很大，所以通过循环文件句柄，读一行写一行到新文件，减少内存使用率
    with open("1.log", "r", encoding="utf-8") as  a, open("2.log", "w", encoding="utf-8") as b:    #自动打开文件，对文件操作后，自动关闭文件
        for i in a:     #循环出原始文件的数据
            b.write(i)  #每循环出一行原始文件数据，写入新文件里
[/code]



**文件操作2.x源码**

[code]

     class file(object)
        def close(self): # real signature unknown; restored from __doc__
            关闭文件
            """
            close() -> None or (perhaps) an integer.  Close the file.
             
            Sets data attribute .closed to True.  A closed file cannot be used for
            further I/O operations.  close() may be called more than once without
            error.  Some kinds of file objects (for example, opened by popen())
            may return an exit status upon closing.
            """
     
        def fileno(self): # real signature unknown; restored from __doc__
            文件描述符  
             """
            fileno() -> integer "file descriptor".
             
            This is needed for lower-level file interfaces, such os.read().
            """
            return 0    
     
        def flush(self): # real signature unknown; restored from __doc__
            刷新文件内部缓冲区
            """ flush() -> None.  Flush the internal I/O buffer. """
            pass
     
     
        def isatty(self): # real signature unknown; restored from __doc__
            判断文件是否是同意tty设备
            """ isatty() -> true or false.  True if the file is connected to a tty device. """
            return False
     
     
        def next(self): # real signature unknown; restored from __doc__
            获取下一行数据，不存在，则报错
            """ x.next() -> the next value, or raise StopIteration """
            pass
     
        def read(self, size=None): # real signature unknown; restored from __doc__
            读取指定字节数据
            """
            read([size]) -> read at most size bytes, returned as a string.
             
            If the size argument is negative or omitted, read until EOF is reached.
            Notice that when in non-blocking mode, less data than what was requested
            may be returned, even if no size parameter was given.
            """
            pass
     
        def readinto(self): # real signature unknown; restored from __doc__
            读取到缓冲区，不要用，将被遗弃
            """ readinto() -> Undocumented.  Don't use this; it may go away. """
            pass
     
        def readline(self, size=None): # real signature unknown; restored from __doc__
            仅读取一行数据
            """
            readline([size]) -> next line from the file, as a string.
             
            Retain newline.  A non-negative size argument limits the maximum
            number of bytes to return (an incomplete line may be returned then).
            Return an empty string at EOF.
            """
            pass
     
        def readlines(self, size=None): # real signature unknown; restored from __doc__
            读取所有数据，并根据换行保存值列表
            """
            readlines([size]) -> list of strings, each a line from the file.
             
            Call readline() repeatedly and return a list of the lines so read.
            The optional size argument, if given, is an approximate bound on the
            total number of bytes in the lines returned.
            """
            return []
     
        def seek(self, offset, whence=None): # real signature unknown; restored from __doc__
            指定文件中指针位置
            """
            seek(offset[, whence]) -> None.  Move to new file position.
             
            Argument offset is a byte count.  Optional argument whence defaults to
    (offset from start of file, offset should be >= 0); other values are 1
            (move relative to current position, positive or negative), and 2 (move
            relative to end of file, usually negative, although many platforms allow
            seeking beyond the end of a file).  If the file is opened in text mode,
            only offsets returned by tell() are legal.  Use of other offsets causes
            undefined behavior.
            Note that not all file objects are seekable.
            """
            pass
     
        def tell(self): # real signature unknown; restored from __doc__
            获取当前指针位置
            """ tell() -> current file position, an integer (may be a long integer). """
            pass
     
        def truncate(self, size=None): # real signature unknown; restored from __doc__
            截断数据，仅保留指定之前数据
            """
            truncate([size]) -> None.  Truncate the file to at most size bytes.
             
            Size defaults to the current file position, as returned by tell().
            """
            pass
     
        def write(self, p_str): # real signature unknown; restored from __doc__
            写内容
            """
            write(str) -> None.  Write string str to file.
             
            Note that due to buffering, flush() or close() may be needed before
            the file on disk reflects the data written.
            """
            pass
     
        def writelines(self, sequence_of_strings): # real signature unknown; restored from __doc__
            将一个字符串列表写入文件
            """
            writelines(sequence_of_strings) -> None.  Write the strings to the file.
             
            Note that newlines are not added.  The sequence can be any iterable object
            producing strings. This is equivalent to calling write() for each string.
            """
            pass
     
        def xreadlines(self): # real signature unknown; restored from __doc__
            可用于逐行读取文件，非全部
            """
            xreadlines() -> returns self.
             
            For backward compatibility. File objects now include the performance
            optimizations previously implemented in the xreadlines module.
            """
            pass
[/code]



**文件操作3.x源码**

[code]

     class TextIOWrapper(_TextIOBase):
        """
        Character and line based layer over a BufferedIOBase object, buffer.
        
        encoding gives the name of the encoding that the stream will be
        decoded or encoded with. It defaults to locale.getpreferredencoding(False).
        
        errors determines the strictness of encoding and decoding (see
        help(codecs.Codec) or the documentation for codecs.register) and
        defaults to "strict".
        
        newline controls how line endings are handled. It can be None, '',
        '\n', '\r', and '\r\n'.  It works as follows:
        
        * On input, if newline is None, universal newlines mode is
          enabled. Lines in the input can end in '\n', '\r', or '\r\n', and
          these are translated into '\n' before being returned to the
          caller. If it is '', universal newline mode is enabled, but line
          endings are returned to the caller untranslated. If it has any of
          the other legal values, input lines are only terminated by the given
          string, and the line ending is returned to the caller untranslated.
        
        * On output, if newline is None, any '\n' characters written are
          translated to the system default line separator, os.linesep. If
          newline is '' or '\n', no translation takes place. If newline is any
          of the other legal values, any '\n' characters written are translated
          to the given string.
        
        If line_buffering is True, a call to flush is implied when a call to
        write contains a newline character.
        """
        def close(self, *args, **kwargs): # real signature unknown
            关闭文件
            pass
    
        def fileno(self, *args, **kwargs): # real signature unknown
            文件描述符  
            pass
    
        def flush(self, *args, **kwargs): # real signature unknown
            刷新文件内部缓冲区
            pass
    
        def isatty(self, *args, **kwargs): # real signature unknown
            判断文件是否是同意tty设备
            pass
    
        def read(self, *args, **kwargs): # real signature unknown
            读取指定字节数据
            pass
    
        def readable(self, *args, **kwargs): # real signature unknown
            是否可读
            pass
    
        def readline(self, *args, **kwargs): # real signature unknown
            仅读取一行数据
            pass
    
        def seek(self, *args, **kwargs): # real signature unknown
            指定文件中指针位置
            pass
    
        def seekable(self, *args, **kwargs): # real signature unknown
            指针是否可操作
            pass
    
        def tell(self, *args, **kwargs): # real signature unknown
            获取指针位置
            pass
    
        def truncate(self, *args, **kwargs): # real signature unknown
            截断数据，仅保留指定之前数据
            pass
    
        def writable(self, *args, **kwargs): # real signature unknown
            是否可写
            pass
    
        def write(self, *args, **kwargs): # real signature unknown
            写内容
            pass
    
        def __getstate__(self, *args, **kwargs): # real signature unknown
            pass
    
        def __init__(self, *args, **kwargs): # real signature unknown
            pass
    
        @staticmethod # known case of __new__
        def __new__(*args, **kwargs): # real signature unknown
            """ Create and return a new object.  See help(type) for accurate signature. """
            pass
    
        def __next__(self, *args, **kwargs): # real signature unknown
            """ Implement next(self). """
            pass
    
        def __repr__(self, *args, **kwargs): # real signature unknown
            """ Return repr(self). """
            pass
    
        buffer = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        closed = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        encoding = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        errors = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        line_buffering = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        name = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        newlines = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        _CHUNK_SIZE = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    
        _finalizing = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
[/code]







[code]

    ** **
[/code]

[code]

    ** **
[/code]

[code]

    ** **
[/code]

[code]

    ** **
[/code]

[code]

    ** **
[/code]

[code]

    ** **
[/code]

[code]

    ** **
[/code]



[code]

    ** **
[/code]

[code]

    ** **
[/code]

