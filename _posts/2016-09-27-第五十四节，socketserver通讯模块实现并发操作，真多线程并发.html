第五十四节，socketserver通讯模块实现并发操作，真多线程并发


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #ff0000; font-size: 18pt;"><strong>socketserver通讯模块实现并发操作，基于select、epoll、socket、多线程，实现的正真多线程多并发</strong></span></p>
<p><strong><strong>socketserver通讯模块底层调用的</strong>socket模块，只是它作了处理基于lo多路复用加多线程，能实现<strong>并发操作，1</strong></strong></p>
<p>SocketServer内部使用 IO多路复用 以及 &ldquo;多线程&rdquo; 和 &ldquo;多进程&rdquo; ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个&ldquo;线程&rdquo;或者&ldquo;进程&rdquo; 专门负责处理当前客户端的所有请求。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>通讯模块实现并发操作服务端，2</strong></span></p>
<p><strong>1，import socketserver #导入模块,3</strong></p>
<p><strong>2，必须创建一个类来，继承两个类socketserver和BaseRequestHandler，注意必须创建一个类来继承这两个模块内部指定的类4</strong></p>
<p><strong>　　<span style="color: #ff0000;"><strong>socketserver，创建类模块指定继承类名称5</strong></span></strong></p>
<p><span style="color: #ff0000;"><strong><strong>　　BaseRequestHandler<strong><strong>，创建类模块指定继承类名称6</strong></strong></strong></strong></span></p>
<p><strong>　　<span style="color: #ff0000;">注意：这个类对象里自动封装了3个普通字段分别为，self.request（客户端连接对象）,self.client_address（客户端IP和端口）,self.server（服务端对象）7</span></strong></p>
<p><strong><span style="color: #ff0000;">　　<strong>self.request（客户端连接对象）8</strong></span></strong></p>
<p><strong><span style="color: #ff0000;"><strong>　　self.client_address（客户端IP和端口）9</strong></span></strong></p>
<p><strong><span style="color: #ff0000;"><strong>　　self.server（服务端对象）10</strong></span></strong></p>
<p><strong>3，创建的类里必须创建一个handle()方法，当客户端连接后就会执行这个<strong>handle()方法，所以各种发送数据和接收数据都是写在这个方法里11</strong></strong></p>
<p><strong><strong>　　<span style="color: #ff0000;">在这个方法里通过对象普通字段的<strong>self.request（客户端连接对象）来做通讯操作12</strong></span></strong></strong></p>
<p><strong><strong><span style="color: #ff0000;"><strong>　　<strong>handle()客户端连接后自动执行方法13</strong></strong></span></strong></strong></p>
<p><span style="color: #000000;"><strong><strong><strong><strong>4，ocketserver.ThreadingTCPServer(元祖类型IP端口, 创建的类名称)设置服务端的IP和端口，并且把创建的类传进去给模块14</strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong><strong><strong><strong>　　<span style="color: #ff0000;">使用方法：定义变量 =&nbsp;<strong><strong><strong><strong>ocketserver.ThreadingTCPServer(元祖类型IP端口, 创建的类名称)15</strong></strong></strong></strong></span></strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong><strong><strong><strong>　　<span style="color: #ff0000;">如：shezhi = socketserver.ThreadingTCPServer(('127.0.0.1', 9999,), bf)16</span></strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong><strong><strong><strong>5，serve_forever() 执行模块，循环等待客户端连接，能处理并发操作，一旦有客户端连接就会执行创建类里的handle方法17</strong></strong></strong></strong></span></p>
<p><span style="color: #000000;"><strong><strong><strong><strong>　　<strong><strong><strong><strong><span style="color: #ff0000;">使用方法：<strong><strong><strong><strong>设置服务端的IP和端口</strong></strong></strong></strong>变量.</span><strong><strong><strong><strong><span style="color: #ff0000;">serve_forever()</span>&nbsp;18</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<p><span style="color: #ff0000;"><strong><strong><strong><strong>　　如：shezhi.serve_forever()19</strong></strong></strong></strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #0000ff;"><strong><strong><strong><strong><strong>并发操作服务端代码20</strong></strong></strong></strong></strong></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/env python</span><span style="color: #008000;">
#</span><span style="color: #008000;"> -*- coding:utf8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">创建并发服务端</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">import</span> socketserver <span style="color: #008000;">#</span><span style="color: #008000;">导入模块</span>

<span style="color: #800000;">"""</span><span style="color: #800000;">创建类</span><span style="color: #800000;">"""</span>
<span style="color: #0000ff;">class</span> bf(socketserver.BaseRequestHandler): <span style="color: #008000;">#</span><span style="color: #008000;">创建一个类，继承两个类socketserver和BaseRequestHandler，注意必须创建一个类来继承这两个模块内部指定的类</span>
     <span style="color: #800000;">"""</span><span style="color: #800000;">定义方法</span><span style="color: #800000;">"""</span>
     <span style="color: #0000ff;">def</span><span style="color: #000000;"> handle(self):
         </span><span style="color: #008000;">#</span><span style="color: #008000;">对象自动封装了（客户端连接对象）,（客户端IP和端口）,（服务端对象）</span>
         <span style="color: #008000;">#</span><span style="color: #008000;"> print self.request（客户端连接对象）,self.client_address（客户端IP和端口）,self.server（服务端对象）</span>
         b = self.request <span style="color: #008000;">#</span><span style="color: #008000;">客户端连接对象</span>
         b.sendall(bytes(<span style="color: #800000;">"</span><span style="color: #800000;">你好欢迎你</span><span style="color: #800000;">"</span>,encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>)) <span style="color: #008000;">#</span><span style="color: #008000;">根据accept()接收到客户端连接对象信息，向客户端发送信息</span>

         <span style="color: #0000ff;">while</span> True: <span style="color: #008000;">#</span><span style="color: #008000;">当客户端连接成功后，进入循环，保持与客户端的通讯</span>
            j = b.recv(1024)<span style="color: #008000;">#</span><span style="color: #008000;">接收客户端发来的信息</span>
            j2 = str(j, encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到的客户端信息转换成字符串</span>
            <span style="color: #0000ff;">if</span> j2 == <span style="color: #800000;">"</span><span style="color: #800000;">q</span><span style="color: #800000;">"</span>: <span style="color: #008000;">#</span><span style="color: #008000;">判断客户端输入q，表示不再与服务端通讯，跳出循环，不在保持客户端的通讯</span>
                <span style="color: #0000ff;">break</span><span style="color: #000000;">
            b.sendall(bytes(j2</span>+<span style="color: #800000;">"</span><span style="color: #800000;">好</span><span style="color: #800000;">"</span>,encoding=<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>)) <span style="color: #008000;">#</span><span style="color: #008000;">将接收到客户端的信息加上一个好字，在发送给客户端</span>

<span style="color: #800000;">"""</span><span style="color: #800000;">设置服务端IP端口，并且把创建类传入socketserver模块</span><span style="color: #800000;">"""</span><span style="color: #000000;">
shezhi </span>= socketserver.ThreadingTCPServer((<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>, 9999,), bf) <span style="color: #008000;">#</span><span style="color: #008000;">设置服务端的IP和端口，并且把创建的类传进去</span>

<span style="color: #800000;">"""</span><span style="color: #800000;">执行socketserver模块</span><span style="color: #800000;">"""</span><span style="color: #000000;">
shezhi.serve_forever() </span><span style="color: #008000;">#</span><span style="color: #008000;">执行模块，循环等待客户端连接，能处理并发操作，一旦有客户端连接就会执行创建类里的handle方法</span></pre>
</div>
<p>&nbsp;<img src="https://images2015.cnblogs.com/blog/955761/201609/955761-20160928073639438-2048589746.png" alt="" /></p>
<p><span style="color: #0000ff;"><strong><strong><strong><strong><strong>并发操作服务端流程图21</strong></strong></strong></strong></strong></span></p>
<p><img src="https://images2015.cnblogs.com/blog/955761/201609/955761-20160928072050703-409204703.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>重点：注意传输数据时的粘包问题22</strong></span></p>
<p><strong>粘包就是一端发了两次信息或数据，第一次发的有可能计算机缓冲区还没发出去，第二次的信息就发到了缓冲区，这样两次的信息粘在一起发出去了，为了避免粘包问题，在第一次发送后接收一下另外一端是否接收到第一次发的信息，如果接收到才发第二次，如果没接收到就不发用，recv()阻塞，</strong></p>
<p><strong>&nbsp;</strong></p></div>