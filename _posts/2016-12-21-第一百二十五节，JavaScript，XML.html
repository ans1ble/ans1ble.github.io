第一百二十五节，JavaScript，XML


			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="color: #0000ff"><strong><span style="font-size: 18pt">JavaScript，XML</span></strong></span></p>
<p>&nbsp;</p>
<p align="left"><strong>学习要点：</strong></p>
<p align="left"><strong>1.IE中的XML</strong></p>
<p align="left"><strong>2.DOM2中的XML</strong></p>
<p align="left"><strong>3.跨浏览器处理XML</strong></p>
<p>&nbsp;</p>
<p align="left"><strong>随着互联网的发展，Web应用程序的丰富，开发人员越来越希望能够使用客户端来操作XML技术。而XML技术一度成为存储和传输结构化数据的标准。所以，本章就详细探讨一下JavaScript中使用XML的技术。</strong></p>
<p align="left"><strong>对于什么是XML，干什么用的，这里就不在赘述了，在以往的XHTML或PHP课程都有涉及到，可以理解成一个微型的结构化的数据库，保存一些小型数据用的。</strong></p>
<p align="left"><strong>&nbsp;</strong></p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>一．</strong><strong>IE</strong><strong>中的XML</strong></span></p>
<p align="left"><strong>在统一的正式规范出来以前，浏览器对于XML的解决方案各不相同。DOM2级提出了动态创建XML DOM规范，DOM3进一步增强了XML DOM。所以，在不同的浏览器实现XML的处理是一件比较麻烦的事情。</strong></p>
<p align="left"><span style="color: #ff0000"><strong>1.创建XMLDOM对象</strong></span></p>
<p align="left"><strong>IE浏览器是第一个原生支持XML的浏览器，而它是通过ActiveX对象实现的。这个对象，只有IE有，一般是IE9之前采用。微软当年为了开发人员方便的处理XML，创建了MSXML库，但却没有让Web开发人员通过浏览器访问相同的对象。</strong></p>
<p align="left"><span style="color: #ff0000"><strong>ActiveXObject()对象，创建xml，ActiveXObject类型，只支持IE，并且只支持IE9以下</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject('MSXML2.DOMDocument');</pre>
</div>
<p>&nbsp;</p>
<p align="center"><span style="color: #ff0000"><strong>ActiveXObject类型</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="211">
<p align="center"><strong>XML版本字符串</strong></p>
</td>
<td width="327">
<p align="center"><strong>说明</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>Microsoft.XmlDom</strong></p>
</td>
<td width="327">
<p align="center"><strong>最初随同IE发布，不建议使用</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>MSXML2.DOMDocument</strong></p>
</td>
<td width="327">
<p align="center"><strong>脚本处理而更新的版本，仅在特殊情况作为备份用</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>MSXML2.DOMDocument.3.0</strong></p>
</td>
<td width="327">
<p align="center"><strong>在JavaScript中使用，这是最低的建议版本</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>MSXML2.DOMDocument.4.0</strong></p>
</td>
<td width="327">
<p align="center"><strong>脚本处理时并不可靠，使用这个版本导致安全警告</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>MSXML2.DOMDocument.5.0</strong></p>
</td>
<td width="327">
<p align="center"><strong>脚本处理时并不可靠，使用这个版本导致安全警告</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>MSXML2.DOMDocument.6.0</strong></p>
</td>
<td width="327">
<p align="center"><strong>脚本能够可靠处理的最新版本</strong></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="left"><span style="color: #ff0000"><strong>PS：在这六个版本中微软只推荐三种：</strong></span></p>
<p align="left"><strong>1.MSXML2.DOMDocument.6.0 最可靠最新的版本</strong></p>
<p align="left"><strong>2.MSXML2.DOMDocument.3.0 兼容性较好的版本</strong></p>
<p align="left"><strong>3.MSXML2.DOMDocument&nbsp;&nbsp;&nbsp; 仅针对IE5.5之前的版本</strong></p>
<p align="left"><span style="color: #ff00ff"><strong>这三个版本在不同的windows平台和浏览器下会有不同的支持，那么为了实现兼容，我们应该考虑这样操作：从6.0-&gt;3.0-&gt;备用版本这条路线进行实现。</strong></span></p>
<p align="left"><span style="color: #ff0000"><strong>兼容不同<strong>windows平台</strong></strong></span></p>
<div class="cnblogs_code">
<pre>alert(createXMLDOM());  <span style="color: #008000">//</span><span style="color: #008000">执行自定义创建xml对象函数</span>

<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>2.载入XML</strong></span></p>
<p align="left"><strong>如果已经获取了XMLDOM对象，那么可以使用loadXML()和load()这两个方法可以分别载入XML字符串或XML文件。</strong></p>
<p><span style="color: #ff0000"><strong>loadXML()载入xml字符串，参数是xml字符串</strong></span><br><strong>使用方式：</strong><br><strong>ActiveXObject()对象.loadXML('参数是xml字符串')</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xml = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xml.loadXML('&lt;root version="1.0"&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;');   <span style="color: #008000">//</span><span style="color: #008000">loadXML()载入xml字符串，参数是xml字符串</span>
alert(xml.xml); <span style="color: #008000">//</span><span style="color: #008000">XML属性可以获取到xml代码</span>


<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p><strong>loadXML参数直接就是XML字符串，如果想效果更好，可以添加换行符\n。.xml属性可以序列化XML，获取整个XML字符串。</strong></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>加载了xml后获取xml元素和html一样的</strong></span></p>
<p align="left"><span style="color: #000000"><strong>当你已经可以加载了XML，那么你就可以用之前学习的DOM来获取XML数据，比如标签内的某个文本。</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xml = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xml.loadXML('&lt;root version="1.0"&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;');   <span style="color: #008000">//</span><span style="color: #008000">loadXML()载入xml字符串，参数是xml字符串</span>
<span style="color: #0000ff">var</span> user = xml.getElementsByTagName('user')[0];    <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;节点</span>
alert(user.tagName);                            <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;元素标签</span>
alert(user.firstChild.nodeValue);                <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;里的值Le</span>



<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>load()载入xml文件，参数是xml文件路径</strong></span><br><strong>使用方式：</strong><br><strong>ActiveXObject()对象.load('xml文件路径')</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xml = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象<br></span></pre>
<pre>xmlDom.async = false;  //同步加载,在服务器测试，等待文件加载完毕后在执行代码</pre>
<pre>xml.load('demo.xml');   <span style="color: #008000">//</span><span style="color: #008000">load()载入xml文件，参数是xml文件路径</span>
alert(xml.xml);  <span style="color: #008000">//</span><span style="color: #008000">打印xml字符串</span>
<span style="color: #0000ff">var</span> user = xml.getElementsByTagName('user')[0];    <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;节点</span>
alert(user.tagName);                            <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;元素标签</span>
alert(user.firstChild.nodeValue);                <span style="color: #008000">//</span><span style="color: #008000">获取&lt;user&gt;里的值Le</span>



<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000"><strong>DOM不单单可以获取XML节点，也可以创建节点</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlDom = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xmlDom.async = <span style="color: #0000ff">false</span>;  <span style="color: #008000">//</span><span style="color: #008000">同步加载,在服务器测试，等待文件加载完毕后在执行代码</span>
xmlDom.load("demo.xml");  <span style="color: #008000">//</span><span style="color: #008000">载入xml文件</span>
<span style="color: #0000ff">var</span> bbb = xmlDom.createElement('bbb');  <span style="color: #008000">//</span><span style="color: #008000">添加一个新节点</span>
<span style="color: #0000ff">var</span> root = xmlDom.documentElement;  <span style="color: #008000">//</span><span style="color: #008000">获取根元素</span>
root.appendChild(bbb); <span style="color: #008000">//</span><span style="color: #008000">将新节点添加到根节点的子节点末尾</span>
<span style="color: #000000">alert(xmlDom.xml);


</span><span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>3.同步及异步</strong></span></p>
<p align="left"><strong>load()方法是用于服务器端载入XML的，并且限制在同一台服务器上的XML文件。那么在载入的时候有两种模式：同步和异步。</strong></p>
<p align="left"><span style="color: #ff00ff"><strong>所谓同步：就是在加载XML完成之前，代码不会继续执行，直到完全加载了XML再返回。好处就是简单方便、坏处就是如果加载的数据停止响应或延迟太久，浏览器会一直堵塞从而造成假死状态。【不推荐】</strong></span></p>
<div class="cnblogs_code">
<pre>xmlDom.async = <span style="color: #0000ff">false</span>;                        <span style="color: #008000">//</span><span style="color: #008000">设置同步，false，可以用PHP测试假死</span></pre>
</div>
<p align="left"><strong><span style="color: #ff00ff">所谓异步：就是在加载XML时，JavaScript会把任务丢给浏览器内部后台去处理，不会造成堵塞，但要配合readystatechange事件使用，所以，通常我们都使用异步方式。</span></strong></p>
<p align="left">&nbsp;</p>
<div class="cnblogs_code">
<pre>xmlDom.async = <span style="color: #0000ff">true</span>;                        <span style="color: #008000">//</span><span style="color: #008000">设置异步，默认</span></pre>
</div>
<p align="left">&nbsp;</p>
<p align="left"><strong><span style="color: #ff00ff">通过异步加载，我们发现获取不到XML的信息。原因是，它并没有完全加载XML就返回了，也就是说，我们需要在浏览器内部加载一点，返回一点，加载一点，返回一点。这个时候，我们需要判断是否完全加载，并且可以使用了，再进行获取输出。<strong>配合readystatechange事件使用【推荐】</strong></span></strong></p>
<p align="left">&nbsp;</p>
<p align="center"><span style="color: #ff0000"><strong>XML DOM中onreadystatechange事件</strong></span></p>
<p align="left">&nbsp;</p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="211">
<p align="center"><strong>就绪状态</strong></p>
</td>
<td width="327">
<p align="center"><strong>说明</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>1</strong></p>
</td>
<td width="327">
<p align="center"><strong>DOM正在加载</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>2</strong></p>
</td>
<td width="327">
<p align="center"><strong>DOM已经加载完数据</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>3</strong></p>
</td>
<td width="327">
<p align="center"><strong>DOM已经可以使用，但某些部分还无法访问</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>4</strong></p>
</td>
<td width="327">
<p align="center"><strong>DOM已经完全可以</strong></p>
</td>
</tr>
<tr>
<td colspan="2" width="537">
<p align="center"><span style="color: #ff0000"><strong>PS：readyState可以获取就绪状态值</strong></span></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="left">&nbsp;</p>
<p><span style="color: #ff0000"><strong>onreadystatechange事件,xml对象事件，当加载外部xml文件是激发，通过readyState属性可以获取xml文件加载的状态，见上表</strong></span><br><strong>使用方式：</strong><br><strong>写在加载文件的前面</strong><br><strong>xml对象.onreadystatechange = 执行函数</strong></p>
<p><span style="color: #ff0000"><strong>readyState属性，可以获取到通过onreadystatechange事件加载的xml文件状态，写在事件函数里面,返回状态码见上表</strong></span><br><strong>使用方式：</strong><br><strong>xml对象.readyState</strong></p>
<p><span style="color: #ff0000"><strong>解决异步不能加载完毕的问题</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlDom = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xmlDom.async = <span style="color: #0000ff">true</span>; <span style="color: #008000">//</span><span style="color: #008000">异步加载</span>
xmlDom.onreadystatechange = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">onreadystatechange事件,xml对象事件，当加载外部xml文件是激发</span>
    <span style="color: #0000ff">if</span> (xmlDom.readyState == 4){  <span style="color: #008000">//</span><span style="color: #008000">readyState属性，可以获取到通过onreadystatechange事件加载的xml文件状态</span>
        <span style="color: #008000">//</span><span style="color: #008000">判断当xml文件加载完毕后，打印出xml里的代码</span>
<span style="color: #000000">        alert(xmlDom.xml);
    }
};
xmlDom.load(</span>"demo.xml");  <span style="color: #008000">//</span><span style="color: #008000">载入xml文件</span>



<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p><span style="color: #0000ff"><strong>PS：可以通过readyState来了解事件的执行次数，将load()方法放到最后不会因为代码的顺序而导致没有加载。并且load()方法必须放在onreadystatechange之后，才能保证就绪状态变化时调用该事件处理程序，因为要先触发</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff00ff; background-color: #ffffff"><strong>虽然可以通过XML DOM文档加载XML文件，但公认的还是XMLHttpRequest对象比较好。这方面内容，我们在Ajax章节详细了解。</strong></span></p>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>2.解析错误</strong></span></p>
<p align="left"><strong>在加载XML时，无论使用loadXML()或load()方法，都有可能遇到XML格式不正确的情况。为了解决这个问题，微软的XML DOM提供了parseError属性。</strong></p>
<p align="center"><span style="color: #ff0000"><strong>parseError属性对象</strong></span></p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="211">
<p align="center"><strong>属性</strong></p>
</td>
<td width="327">
<p align="center"><strong>说明</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>errorCode</strong></p>
</td>
<td width="327">
<p align="center"><strong>发生的错误类型的数字代号，没有错误返回0</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>filepos</strong></p>
</td>
<td width="327">
<p align="center"><strong>发生错误文件中的位置</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>line</strong></p>
</td>
<td width="327">
<p align="center"><strong>错误行号</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>linepos</strong></p>
</td>
<td width="327">
<p align="center"><strong>遇到错误行号那一行上的字符的位置</strong></p>
</td>
</tr>
<tr>
<td width="211">
<p align="center"><strong>reason</strong></p>
</td>
<td width="327">
<p align="center"><strong>错误的解释信息</strong></p>
</td>
</tr>
</tbody>
</table>
</div>
<p align="left"><strong><span style="color: #ff0000">parseError属性对象，是处理加载xml文件时遇到错误的对象，对象下有5个属性分别返回错误类型，见上表</span></strong></p>
<p align="left">&nbsp;</p>
<p><strong>使用方式：</strong><br><strong>xml对象.parseError.错误属性</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlDom = createXMLDOM();  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xmlDom.async = <span style="color: #0000ff">true</span>; <span style="color: #008000">//</span><span style="color: #008000">异步加载</span>
xmlDom.onreadystatechange = <span style="color: #0000ff">function</span> () {  <span style="color: #008000">//</span><span style="color: #008000">onreadystatechange事件,xml对象事件，当加载外部xml文件是激发</span>
    <span style="color: #0000ff">if</span> (xmlDom.readyState == 4) {  <span style="color: #008000">//</span><span style="color: #008000">readyState属性，可以获取到通过onreadystatechange事件加载的xml文件状态</span>
        <span style="color: #008000">//</span><span style="color: #008000">判断当xml文件加载完毕后，执行里面代码</span>
        <span style="color: #0000ff">if</span> (xmlDom.parseError.errorCode == 0) {  <span style="color: #008000">//</span><span style="color: #008000">判断文件是否有错</span>
            <span style="color: #008000">//</span><span style="color: #008000">如果没有错误，打印出xml代码</span>
<span style="color: #000000">            alert(xmlDom.xml);
        } </span><span style="color: #0000ff">else</span> {  <span style="color: #008000">//</span><span style="color: #008000">如果有错误</span>
            <span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，打印出相应的错误类型</span>
            <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('错误行号：' + xmlDom.parseError.line +
                '\n错误代号：' + xmlDom.parseError.errorCode +
                '\n错误解释：' +<span style="color: #000000"> xmlDom.parseError.reason);
        }
    }
};
xmlDom.load(</span>"demo.xml");  <span style="color: #008000">//</span><span style="color: #008000">载入xml文件</span>



<span style="color: #008000">//</span><span style="color: #008000">兼容不同windows平台</span>
<span style="color: #0000ff">function</span> createXMLDOM() {  <span style="color: #008000">//</span><span style="color: #008000">自定义函数，创建xml对象</span>
    <span style="color: #0000ff">var</span> version = [   <span style="color: #008000">//</span><span style="color: #008000">创建数组，元素是ActiveXObject类型</span>
                            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
                            </span>'MSXML2.DOMDocument'<span style="color: #000000">
    ];
    </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i ++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
        <span style="color: #0000ff">try</span> {  <span style="color: #008000">//</span><span style="color: #008000">尝试执行循环到的ActiveXObject类型</span>
            <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">new</span> ActiveXObject(version[i]);  <span style="color: #008000">//</span><span style="color: #008000">执行成功</span>
            <span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">返回创建xml对象，并且退出当前函数</span>
        } <span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错</span>
            <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出错误</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您的系统或浏览器不支持MSXML！');        <span style="color: #008000">//</span><span style="color: #008000">循环后抛出错误</span>
}</pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>二．DOM2中的XML</strong></span></p>
<p align="left"><span style="color: #ff00ff; background-color: #ffffff"><strong>&nbsp;<strong>DOM2中无法实现字符串方式创建xml对象</strong></strong></span></p>
<p align="left"><strong>IE可以实现了对XML字符串或XML文件的读取，其他浏览器也各自实现了对XML处理功能。DOM2级在document.implementaion中引入了createDocument()方法。IE9、Firefox、Opera、Chrome和Safari都支持这个方法。</strong></p>
<p><span style="color: #ff0000"><strong>implementaion对象，xml对象</strong></span><br><strong>使用方式;</strong><br><strong>document.implementaion.createDocument()</strong></p>
<p><span style="color: #ff0000"><strong>createDocument()方法，创建xml对象，3个参数，参数一命名空间xml没有命名空间留空字符串，参数二xml根标签，参数三文档声明，没有文档声明写null</strong></span><br><strong>使用方式：</strong><br><strong>document.implementaion.createDocument('',xml根标签,null)</strong></p>
<p align="left"><span style="color: #ff0000"><strong>1.创建XMLDOM对象</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">1.创建XMLDOM对象</span>
<span style="color: #0000ff">var</span> xmlDom = document.implementation.createDocument('','root',<span style="color: #0000ff">null</span>);    <span style="color: #008000">//</span><span style="color: #008000">创建xmlDom</span>
<span style="color: #0000ff">var</span> us = xmlDom.createElement('us');                            <span style="color: #008000">//</span><span style="color: #008000">创建us新元素节点</span>
xmlDom.getElementsByTagName('root')[0].appendChild(us);            <span style="color: #008000">//</span><span style="color: #008000">将新元素节点添加到root下</span>
<span style="color: #0000ff">var</span> value = xmlDom.createTextNode('Lee');                        <span style="color: #008000">//</span><span style="color: #008000">创建文本节点</span>
xmlDom.getElementsByTagName('us')[0].appendChild(value);        <span style="color: #008000">//</span><span style="color: #008000">将文本节点添加到us下</span>
alert(xmlDom.getElementsByTagName('root')[0].tagName);  <span style="color: #008000">//</span><span style="color: #008000">打印出根元素的标签名称</span>
alert(xmlDom.getElementsByTagName('us')[0].firstChild.nodeValue); <span style="color: #008000">//</span><span style="color: #008000">打印出user元素的标签下的文本节点值</span></pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>PS：由于DOM2中不支持loadXML()方法，所以，无法简易的直接创建XML字符串。所以，只能采用以上的做法。</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>PS：createDocument()方法需要传递三个参数，命名空间，根标签名和文档声明，由于JavaScript管理命名空间比较困难，所以留空即可。文档声明一般根本用不到，直接null即可。命名空间和文档声明留空，表示创建XMLDOM对象不需要命名空间和文档声明。</strong></span></p>
<p align="left"><span style="color: #0000ff"><strong>PS：命名空间的用途是防止太多的重名而进行的分类，文档类型表明此文档符合哪种规范，而这里创建XMLDOM不需要使用这两个参数，所以留空即可。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>2.载入XML</strong></span></p>
<p align="left"><strong>DOM2只支持load()方法，载入一个同一台服务器的外部XML文件。当然，DOM2也有async属性，来表面同步或异步，默认异步。</strong></p>
<p align="left"><span style="color: #ff00ff"><strong><strong>不管在同步或异步来获取load()方法只有Mozilla的Firefox才能支持，只不过新版的Opera也是支持的，其他浏览器则不支持</strong></strong></span></p>
<p align="left"><span style="color: #ff00ff"><strong>同步情况下</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">同步情况下</span>
<span style="color: #0000ff">var</span> xmlDom = document.implementation.createDocument('','root',<span style="color: #0000ff">null</span>);  <span style="color: #008000">//</span><span style="color: #008000">创建xml对象</span>
xmlDom.async = <span style="color: #0000ff">false</span>; <span style="color: #008000">//</span><span style="color: #008000">加载文件方式同步，加载XML完成之前，代码不会继续执行，直到完全加载了XML再返回</span>
xmlDom.load('demo.xml'); <span style="color: #008000">//</span><span style="color: #008000">加载xml文件</span>
alert(xmlDom.getElementsByTagName('user')[0].tagName);  <span style="color: #008000">//</span><span style="color: #008000">获取user标签的，标签名称</span></pre>
</div>
<p align="left"><span style="color: #ff00ff"><strong>异步情况下</strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000">//</span><span style="color: #008000">异步情况下</span>
<span style="color: #0000ff">var</span> xmlDom = document.implementation.createDocument('', 'root', <span style="color: #0000ff">null</span><span style="color: #000000">);
xmlDom.async </span>= <span style="color: #0000ff">true</span>;  <span style="color: #008000">//</span><span style="color: #008000">异步</span>
addEvent(xmlDom, 'load', <span style="color: #0000ff">function</span> () {                    <span style="color: #008000">//</span><span style="color: #008000">异步直接用onload即可，等待页面加载完毕后执行函数</span>
    alert(<span style="color: #0000ff">this</span>.getElementsByTagName('user')[0].tagName);  <span style="color: #008000">//</span><span style="color: #008000">打印当前xml对象里，user元素的，标签名称</span>
<span style="color: #000000">});
xmlDom.load(</span>'demo.xml'); <span style="color: #008000">//</span><span style="color: #008000">加载xml文件</span>


<span style="color: #008000">//</span><span style="color: #008000">跨浏览器添加事件，添加事件兼容</span>
<span style="color: #0000ff">function</span> addEvent(obj, type, fn) {     <span style="color: #008000">//</span><span style="color: #008000">添加事件函数，接收3个参数，1事件对象，2事件名称，3事件函数</span>
    <span style="color: #008000">//</span><span style="color: #008000">判断浏览器如果支持w3c</span>
    <span style="color: #0000ff">if</span><span style="color: #000000"> (obj.addEventListener) {
        </span><span style="color: #008000">//</span><span style="color: #008000">就用w3c的addEventListener方法添加对象，将事件名称和事件函数传入添加事件</span>
        obj.addEventListener(type, fn, <span style="color: #0000ff">false</span><span style="color: #000000">);
    } </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (obj.attachEvent) {   <span style="color: #008000">//</span><span style="color: #008000">判断如果浏览器是IE9以下，就用IE的方法attachEvent添加事件</span>
        <span style="color: #008000">//</span><span style="color: #008000">将事件名称和事件函数传入创建对象</span>
        obj.attachEvent('on' +<span style="color: #000000"> type, fn);
    }
}</span></pre>
</div>
<p align="left"><span style="color: #0000ff"><strong>PS：不管在同步或异步来获取load()方法只有Mozilla的Firefox才能支持，只不过新版的Opera也是支持的，其他浏览器则不支持。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><strong><span style="color: #ff0000">3.DOMParser类型，用于定义字符串方式xml</span></strong></p>
<p align="left"><strong>由于DOM2没有loadXML()方法直接解析XML字符串，所以提供了DOMParser类型来创建XML DOM对象。IE9、Safari、Chrome和Opera都支持这个类型。<strong>DOMParser下面有一个方法parseFromString()创建xml对象</strong></strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong><strong>parseFromString()方法，创建xml对象，用于创建<strong>DOMParser类型的xml对象，有两个参数，参数一是xml字符串，参数二是xml类型text/xml</strong></strong></strong></strong></span></p>
<p align="left"><span style="color: #000000"><strong><strong><strong><strong>使用方式：</strong></strong></strong></strong></span></p>
<p align="left"><span style="color: #000000"><strong><strong><strong><strong>DOMParser对象.<strong><strong><strong>parseFromString(<strong><strong><strong><strong>xml字符串</strong></strong></strong></strong>,'<strong><strong><strong><strong>text/xml</strong></strong></strong></strong>')</strong></strong></strong></strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlParser = <span style="color: #0000ff">new</span> DOMParser();                        <span style="color: #008000">//</span><span style="color: #008000">创建DOMParser对象</span><span style="color: #008000">
//</span><span style="color: #008000">创建xml字符串</span>
<span style="color: #0000ff">var</span> xmlStr = '&lt;root&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;';    <span style="color: #008000">//</span><span style="color: #008000">XML字符串</span>
<span style="color: #0000ff">var</span> xmlDom = xmlParser.parseFromString(xmlStr, 'text/xml');    <span style="color: #008000">//</span><span style="color: #008000">创建XML DOM对象</span>
alert(xmlDom.getElementsByTagName('user')[0].tagName);    <span style="color: #008000">//</span><span style="color: #008000">获取user元素标签名</span></pre>
</div>
<p align="left"><strong>PS：XML DOM对象是通过DOMParser对象中的parseFromString方法来创建的，两个参数：XML字符串和内容类型text/xml。</strong></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>4.XMLSerializer类型，用于序列化XML输出</strong></span></p>
<p align="left"><strong>由于DOM2没有序列化XML的属性，所以提供了XMLSerializer类型来帮助序列化XML字符串。IE9、Safari、Chrome和Opera都支持这个类型。<strong>XMLSerializer类型下面有一个serializeToString()方法序列化XML</strong></strong></p>
<p align="left"><span style="color: #ff0000"><strong><strong><strong><strong>serializeToString()方法，<strong>用于序列化XML输出，有一个参数xml对象<strong>DOM</strong></strong></strong></strong></strong></strong></span></p>
<p align="left"><span style="color: #000000"><strong><strong><strong><strong><strong><strong>使用方式：</strong></strong></strong></strong></strong></strong></span></p>
<p align="left"><span style="color: #000000"><strong><strong><strong><strong><strong><strong><strong>XMLSerializer对象.<strong><strong><strong><strong>serializeToString(<strong><strong><strong><strong><strong>xml对象<strong>DOM</strong></strong></strong></strong></strong></strong>)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlParser = <span style="color: #0000ff">new</span> DOMParser();                        <span style="color: #008000">//</span><span style="color: #008000">创建DOMParser对象</span><span style="color: #008000">
//</span><span style="color: #008000">创建xml字符串</span>
<span style="color: #0000ff">var</span> xmlStr = '&lt;root&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;';    <span style="color: #008000">//</span><span style="color: #008000">XML字符串</span>
<span style="color: #0000ff">var</span> xmlDom = xmlParser.parseFromString(xmlStr, 'text/xml');    <span style="color: #008000">//</span><span style="color: #008000">创建XML DOM对象</span>

<span style="color: #0000ff">var</span> serializer = <span style="color: #0000ff">new</span> XMLSerializer();            <span style="color: #008000">//</span><span style="color: #008000">创建XMLSerializer对象</span>
<span style="color: #0000ff">var</span> xml = serializer.serializeToString(xmlDom);    <span style="color: #008000">//</span><span style="color: #008000">序列化XML</span>
alert(xml); <span style="color: #008000">//</span><span style="color: #008000">序列化打印出xml</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><span style="color: #ff0000"><strong>5.解析错误</strong></span></p>
<p align="left"><strong>在DOM2级处理XML发生错误时，并没有提供特有的对象来捕获错误，而是直接生成另一个错误的XML文档，通过这个文档可以获取错误信息。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xmlParser = <span style="color: #0000ff">new</span> DOMParser();                        <span style="color: #008000">//</span><span style="color: #008000">创建DOMParser对象</span><span style="color: #008000">
//</span><span style="color: #008000">创建xml字符串</span>
<span style="color: #0000ff">var</span> xmlStr = '&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;';    <span style="color: #008000">//</span><span style="color: #008000">XML字符串</span>
<span style="color: #0000ff">var</span> xmlDom = xmlParser.parseFromString(xmlStr, 'text/xml');    <span style="color: #008000">//</span><span style="color: #008000">创建XML DOM对象</span>

<span style="color: #0000ff">var</span> serializer = <span style="color: #0000ff">new</span> XMLSerializer();            <span style="color: #008000">//</span><span style="color: #008000">创建XMLSerializer对象</span>
<span style="color: #0000ff">var</span> xml = serializer.serializeToString(xmlDom);    <span style="color: #008000">//</span><span style="color: #008000">序列化XML</span><span style="color: #008000">
//</span><span style="color: #008000">获取xml错误序列化后的错误文件parsererror标签，标签里面是错误信息</span>
<span style="color: #0000ff">var</span> errors = xmlDom.getElementsByTagName('parsererror'<span style="color: #000000">);
</span><span style="color: #0000ff">if</span> (errors.length &gt; 0) {  <span style="color: #008000">//</span><span style="color: #008000">判断错误文件标签大于0说明xml有错误</span>
    <span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，获取第一个parsererror标签，并且获取到标签的文本内容</span>
    <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('XML格式有误：' + errors[0<span style="color: #000000">].textContent);
}

alert(xml); </span><span style="color: #008000">//</span><span style="color: #008000">序列化打印出xml,如果出错会得到一个错误文件</span></pre>
</div>
<p align="left"><span style="color: #ff00ff"><strong>PS：errors[0].firstChild.nodeValue也可以使用errors[0].textContent来代替。</strong></span></p>
<p align="left">&nbsp;</p>
<p align="left"><span style="color: #ff0000; background-color: #ffff00"><strong>三．</strong><strong>跨浏览器处理XML</strong></span></p>
<p align="left"><strong>如果要实现跨浏览器就要思考几个个问题：1.load()只有IE、Firefox、Opera支持，所以无法跨浏览器；2.获取XML DOM对象顺序问题，先判断先进的DOM2的，然后再去判断落后的IE；3.针对不同的IE和DOM2级要使用不同的序列化。4.针对不同的报错进行不同的报错机制。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff">var</span> xml = '&lt;root&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;';  <span style="color: #008000">//</span><span style="color: #008000">定义xml字符串</span>
<span style="color: #0000ff">var</span> xmldom = getXMLDOM(xml); <span style="color: #008000">//</span><span style="color: #008000">创建XML DOM对象,接收xml字符串</span>
alert(serializeXML(xmldom)); <span style="color: #008000">//</span><span style="color: #008000">打印序列化xml,接收XML DOM对象</span>


<span style="color: #008000">//</span><span style="color: #008000">首先，我们需要跨浏览器获取XML DOM</span>
<span style="color: #0000ff">function</span> getXMLDOM(xmlStr) {  <span style="color: #008000">//</span><span style="color: #008000">自定义跨浏览器创建xml DOM对象，接收一个参数xml字符串</span>
    <span style="color: #0000ff">var</span> xmlDom = <span style="color: #0000ff">null</span>;  <span style="color: #008000">//</span><span style="color: #008000">初始化一个对象</span>

    <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> window.DOMParser != 'undefined') {        <span style="color: #008000">//</span><span style="color: #008000">判断DOMParser类型不等于undefined说明支持</span>
        <span style="color: #008000">//</span><span style="color: #008000">创建DOMParser对象，并且创建xml DOM对象</span>
        xmlDom = (<span style="color: #0000ff">new</span> DOMParser()).parseFromString(xmlStr, 'text/xml'<span style="color: #000000">);
        </span><span style="color: #008000">//</span><span style="color: #008000">获取错误信息的parsererror标签</span>
        <span style="color: #0000ff">var</span> errors = xmlDom.getElementsByTagName('parsererror'<span style="color: #000000">);
        </span><span style="color: #008000">//</span><span style="color: #008000">判断错误信息标签返回集合长度大于0，说明xml有错误</span>
        <span style="color: #0000ff">if</span> (errors.length &gt; 0<span style="color: #000000">) {
            </span><span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，获取到第一个错误标签，并且获取到他的文本内容</span>
            <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('XML解析错误：' + errors[0<span style="color: #000000">].firstChild.nodeValue);
        }
    </span><span style="color: #008000">//</span><span style="color: #008000">如果不支持DOMParser类型，尝试IE的方法</span>
    } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> window.ActiveXObject != 'undefined') {    <span style="color: #008000">//</span><span style="color: #008000">判断ActiveXObject类型不等于undefined说明支持</span>
        <span style="color: #0000ff">var</span> version = [  <span style="color: #008000">//</span><span style="color: #008000">创建一个数组，元素分别为3个xml版本</span>
            'MSXML2.DOMDocument.6.0'<span style="color: #000000">,
            </span>'MSXML2.DOMDocument.3.0'<span style="color: #000000">,
            </span>'MSXML2.DOMDocument'<span style="color: #000000">
        ];
        </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">var</span> i = 0; i &lt; version.length; i++) {  <span style="color: #008000">//</span><span style="color: #008000">根据数组的长度循环次数</span>
            <span style="color: #0000ff">try</span><span style="color: #000000"> {
                </span><span style="color: #008000">//</span><span style="color: #008000">尝试着执行每次循环到的xml版本，创建xml对象</span>
                xmlDom = <span style="color: #0000ff">new</span><span style="color: #000000"> ActiveXObject(version[i]);
            } </span><span style="color: #0000ff">catch</span> (e) {  <span style="color: #008000">//</span><span style="color: #008000">如果出错跳过执行第二次循环</span>
                <span style="color: #008000">//</span><span style="color: #008000">跳过</span>
<span style="color: #000000">            }
        }
        xmlDom.loadXML(xmlStr);  </span><span style="color: #008000">//</span><span style="color: #008000">载入xml字符串</span>
        <span style="color: #0000ff">if</span> (xmlDom.parseError != 0) {  <span style="color: #008000">//</span><span style="color: #008000">判断载入xml错误返回代码，如果不等于0说明xml有错</span>
            <span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，返回错误的解释信息</span>
            <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('XML解析错误：' +<span style="color: #000000"> xmlDom.parseError.reason);
        }
    } </span><span style="color: #0000ff">else</span> {  <span style="color: #008000">//</span><span style="color: #008000">如果 上面两种方式都不支持</span>
        <span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出您所使用的系统或浏览器不支持XML DOM！</span>
        <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('您所使用的系统或浏览器不支持XML DOM！'<span style="color: #000000">);
    }

    </span><span style="color: #0000ff">return</span> xmlDom;  <span style="color: #008000">//</span><span style="color: #008000">最后返回创建的xmlDOM对象</span>
<span style="color: #000000">}

</span><span style="color: #008000">//</span><span style="color: #008000">其次，我们还必须跨浏览器序列化XML</span>
<span style="color: #0000ff">function</span> serializeXML(xmlDom) {  <span style="color: #008000">//</span><span style="color: #008000">序列化xml函数，接收xmlDOM对象对象</span>
    <span style="color: #0000ff">var</span> xml = '';  <span style="color: #008000">//</span><span style="color: #008000">初始化一个变量等于空字符串</span>
    <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> XMLSerializer != 'undefined') {  <span style="color: #008000">//</span><span style="color: #008000">判断XMLSerializer类型，不等于undefined，说明支持序列化</span>
        <span style="color: #008000">//</span><span style="color: #008000">给xml重新赋值，创建XMLSerializer对象，并且使用serializeToString方法序列化</span>
        xml = (<span style="color: #0000ff">new</span><span style="color: #000000"> XMLSerializer()).serializeToString(xmlDom);
    </span><span style="color: #008000">//</span><span style="color: #008000">如果不支持XMLSerializer类型</span>
    } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (<span style="color: #0000ff">typeof</span> xmlDom.xml != 'undefined') { <span style="color: #008000">//</span><span style="color: #008000">判断IE方式xmlDOM对象下的xml属性是否等于undefined，不等于说明支持</span>
        <span style="color: #008000">//</span><span style="color: #008000">给xml重新赋值，序列化xml</span>
        xml =<span style="color: #000000"> xmlDom.xml;
    } </span><span style="color: #0000ff">else</span> { <span style="color: #008000">//</span><span style="color: #008000">如果上面两种都不支持</span>
        <span style="color: #008000">//</span><span style="color: #008000">创建一个错误对象，抛出无法解析XML！错误信息</span>
        <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> Error('无法解析XML！'<span style="color: #000000">);
    }
    </span><span style="color: #0000ff">return</span> xml; <span style="color: #008000">//</span><span style="color: #008000">最后返回序列化</span>
}</pre>
</div>
<p align="left"><span style="color: #ff00ff"><strong>PS：由于兼容性序列化过程有一定的差异，可能返回的结果字符串可能会有一些不同。至于load()加载XML文件则因为只有部分浏览器支持而无法跨浏览器。</strong></span></p>
<p align="left">&nbsp;</p></div>